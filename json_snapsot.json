    "path": ".env",
    "content": "BOT_TOKEN=\n\nDATABASE_URL=sqlite+aiosqlite:///./bot.db\n\nTZ=Europe/Kyiv\n\nWEB_HOST=0.0.0.0\nWEB_PORT=5005\nWEB_BASE_URL=http://65.109.6.20:5005\n\nADMIN_IDS=196937248\nUPLOAD_SECRET=change_me_to_a_long_random_secret\n\nIMPORT_TMP_DIR=/tmp/anki_listen_bot_import\n\nSIMILARITY_OK=93\nSIMILARITY_ALMOST=85\nLEARNING_STEPS_MINUTES=1,10\nLEARNING_GRADUATE_DAYS=1\n\n# \u0449\u043e\u0431 \u043f\u0435\u0440\u0435\u043a\u043b\u0430\u0434 \u0442\u043e\u0447\u043d\u043e \u0440\u043e\u0431\u0438\u0432\u0441\u044f \u043f\u0440\u0438 \u0456\u043c\u043f\u043e\u0440\u0442\u0456:\nTRANSLATE_ENABLED=1\nTRANSLATE_SOURCE_LANG=en\nTRANSLATE_TARGET_LANG=uk\n"
    "path": ".env.example",
    "content": "BOT_TOKEN=123456:ABCDEF-your-bot-token\n# SQLite default if DATABASE_URL omitted:\n# DATABASE_URL=sqlite+aiosqlite:///./bot.db\n# PostgreSQL example:\n# DATABASE_URL=postgresql+asyncpg://user:pass@127.0.0.1:5432/anki_listen_bot\nTZ=Europe/Kyiv\nSIMILARITY_OK=93\nSIMILARITY_ALMOST=85\nLEARNING_STEPS_MINUTES=1,10\nLEARNING_GRADUATE_DAYS=1\nIMPORT_TMP_DIR=/tmp/anki_listen_bot_import\nADMIN_IDS=123456789,987654321  # Telegram user IDs allowed to upload/manage decks\nUPLOAD_SECRET=change_me_to_a_long_random_secret\nWEB_HOST=0.0.0.0\nWEB_PORT=8080\nWEB_BASE_URL=http://127.0.0.1:8080  # public URL to open upload page from Telegram\n"
    "path": ".pytest_cache/.gitignore",
    "content": "# Created by pytest automatically.\n*\n"
    "path": ".pytest_cache/README.md",
    "content": "# pytest cache directory #\n\nThis directory contains data from the pytest's cache plugin,\nwhich provides the `--lf` and `--ff` options, as well as the `cache` fixture.\n\n**Do not** commit this to version control.\n\nSee [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.\n"
    "content": "[\n  \"tests/test_admin_students.py::test_progress_history_and_overall\",\n  \"tests/test_admin_students.py::test_unenroll_all_students_wipe_progress\",\n  \"tests/test_admin_students.py::test_unenroll_student_wipe_progress\",\n  \"tests/test_study_flow.py::test_learning_card_prioritized_over_main_queue\",\n  \"tests/test_study_flow.py::test_record_answered_card_updates_pos_only_for_main_queue\",\n  \"tests/test_study_flow.py::test_scheduler_sends_learning_after_main_queue\",\n  \"tests/test_study_flow.py::test_scheduler_skips_when_current_card_active\"\n]"
    "path": "README.md",
    "content": "# anki_listen_bot (Telegram-only listening SRS)\n\n## What it does\n- Admin uploads an `.apkg` (video/audio on front, subtitle text on back).\n- Bot imports, caches Telegram `file_id`, asks admin only `new_per_day`.\n- Bot returns student link: `t.me/<bot>?start=deck_<token>`\n- Student flow: open deck link -> media is sent immediately -> type answer -> immediate compare -> auto-next in 1 second.\n- Daily: at 07:00 (TZ), bot sends the first card for each enrolled deck.\n- When finished: \"It's all for today\" + button **Study more**.\n- Button: **Bad card** (flags + suspends that card for that student, no penalty).\n\n## Requirements\n- Python 3.11+ recommended\n- A Telegram bot token from BotFather\n\n## Install (venv)\n```bash\ncd anki_listen_bot\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\ncp .env.example .env\nnano .env   # set BOT_TOKEN and optionally DATABASE_URL\n```\n\n## Run\n```bash\nsource .venv/bin/activate\npython -m app.main\n```\n\n## Notes about `.apkg` format\n- Bot expects:\n  - Front contains media reference (`[sound:...]` or `<video ... src=\"...\">`)\n  - Back contains subtitle text (plain or HTML)\n  - Optional alternative answers separated by `||`\n\n## Troubleshooting\n- If media upload fails for some cards, they will be skipped and reported.\n- Very large videos may exceed Telegram limits; prefer short snippets.\n\n## Large deck uploads (web)\n- Set `ADMIN_IDS` and `UPLOAD_SECRET` in `.env`\n- Set `WEB_BASE_URL` to your public URL (domain + port)\n- Run `python -m app.main`\n- In Telegram, admins will see **Upload deck (large)** button on /start\n"
    "path": "app/__init__.py",
    "content": ""
    "path": "app/bot/factory.py",
    "content": "from __future__ import annotations\n\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.fsm.storage.memory import MemoryStorage\n\nfrom app.handlers.student_join import router as student_join_router\nfrom app.handlers.common import router as common_router\nfrom app.handlers.admin_import import router as admin_import_router\nfrom app.handlers.admin_manage import router as admin_manage_router\nfrom app.handlers.admin_students import router as admin_students_router\nfrom app.handlers.student_study import router as student_study_router\nfrom app.handlers.callbacks import router as callbacks_router\n\ndef create_bot(token: str) -> Bot:\n    return Bot(token=token)\n\ndef create_dispatcher() -> Dispatcher:\n    dp = Dispatcher(storage=MemoryStorage())\n    # Deep-link /start must be handled before generic /start.\n    dp.include_router(student_join_router)\n    dp.include_router(common_router)\n\n    dp.include_router(admin_import_router)\n    dp.include_router(admin_manage_router)\n    dp.include_router(admin_students_router)\n    dp.include_router(student_study_router)\n    dp.include_router(callbacks_router)\n    return dp\n"
    "path": "app/bot/keyboards.py",
    "content": "from __future__ import annotations\nfrom aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton\n\nfrom app.services.admin_auth import make_upload_token\n\ndef kb_bad_card(deck_id: str, card_id: str) -> InlineKeyboardMarkup:\n    # Telegram callback_data max is 64 bytes.\n    return InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"Bad card\", callback_data=f\"bad:{card_id}\")]\n    ])\n\ndef kb_study_more(deck_id: str) -> InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"Study more\", callback_data=f\"more:{deck_id}\")]\n    ])\n\ndef kb_admin_deck(deck_id: str) -> InlineKeyboardMarkup:\n    return InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"Student list\", callback_data=f\"ad_students:{deck_id}:0\")],\n        [InlineKeyboardButton(text=\"Export bad cards\", callback_data=f\"ad_export:{deck_id}\")],\n        [InlineKeyboardButton(text=\"Set N/day\", callback_data=f\"ad_setn:{deck_id}\")],\n        [InlineKeyboardButton(text=\"Rotate link\", callback_data=f\"ad_rot:{deck_id}\")],\n        [InlineKeyboardButton(text=\"Unenroll everyone\", callback_data=f\"ad_unenroll_all:{deck_id}\")],\n        [InlineKeyboardButton(text=\"Disable deck\", callback_data=f\"ad_dis:{deck_id}\")],\n        [InlineKeyboardButton(text=\"Delete deck\", callback_data=f\"ad_del:{deck_id}\")],\n    ])\n\n\ndef kb_admin_deck_list(items: list[tuple[str, str, bool]]) -> InlineKeyboardMarkup:\n    \"\"\"items: (deck_id, title, is_active)\"\"\"\n    rows = []\n    for deck_id, title, is_active in items:\n        status = \"\u2705\" if is_active else \"\ud83d\udeab\"\n        rows.append([\n            InlineKeyboardButton(text=f\"{status} {title[:40]}\", callback_data=f\"ad_open:{deck_id}\"),\n            InlineKeyboardButton(text=\"\ud83d\uddd1\", callback_data=f\"ad_del:{deck_id}\"),\n        ])\n    rows.append([InlineKeyboardButton(text=\"Close\", callback_data=\"ad_close\")])\n    return InlineKeyboardMarkup(inline_keyboard=rows)\n\ndef kb_admin_home(settings, admin_id: int) -> InlineKeyboardMarkup:\n    tok = make_upload_token(settings.upload_secret, admin_id, ttl_seconds=3600)\n    url = f\"{settings.web_base_url}/upload?token={tok}\"\n    return InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"All decks\", callback_data=\"ad_list\")],\n        [InlineKeyboardButton(text=\"Upload deck (large)\", url=url)],\n])\n"
    "path": "app/bot/messages.py",
    "content": "from __future__ import annotations\n\ndef start_message() -> str:\n    return (\n        \"Students: open a deck link to start (the first card is sent immediately).\\n\"\n        \"Every day at 07:00 you will receive today's first card automatically.\\n\"\n        \"Admins: send .apkg (small) or use 'Upload deck (large)'.\"\n    )\n\ndef admin_import_prompt() -> str:\n    return \"Upload received. Importing... Please wait.\"\n\ndef ask_new_per_day() -> str:\n    return \"How many NEW cards per day should students get? Send a number (e.g., 10).\"\n\ndef invalid_number() -> str:\n    return \"Please send a valid integer number.\"\n\ndef deck_link(bot_username: str, deck_token: str) -> str:\n    return f\"https://t.me/{bot_username}?start=deck_{deck_token}\"\n\ndef join_ok(deck_title: str) -> str:\n    return f\"Joined deck: {deck_title}\"\n\ndef deck_inactive() -> str:\n    return \"This deck is inactive.\"\n\ndef deck_not_found() -> str:\n    return \"Deck not found (invalid link).\"\n\ndef no_cards_today() -> str:\n    return \"It's all for today.\"\n\ndef done_today() -> str:\n    return \"It's all for today.\"\n\ndef need_today_first() -> str:\n    return \"No active card. Open the deck link (or wait for 07:00).\"\n\ndef flagged_bad() -> str:\n    return \"Flagged as bad card. Skipping...\"\n"
    "path": "app/config.py",
    "content": "from __future__ import annotations\n\nimport os\nfrom dataclasses import dataclass\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\ndef _get_env(name: str, default: str | None = None) -> str:\n    v = os.getenv(name, default)\n    if v is None or v.strip() == \"\":\n        raise RuntimeError(f\"Missing required env var: {name}\")\n    return v\n\ndef _get_int(name: str, default: int) -> int:\n    v = os.getenv(name)\n    if v is None or v.strip() == \"\":\n        return default\n    try:\n        return int(v)\n    except ValueError as e:\n        raise RuntimeError(f\"Invalid int for {name}: {v}\") from e\n\n\ndef _get_bool(name: str, default: bool) -> bool:\n    v = os.getenv(name)\n    if v is None or v.strip() == '':\n        return default\n    v = v.strip().lower()\n    if v in ('1','true','yes','y','on'):\n        return True\n    if v in ('0','false','no','n','off'):\n        return False\n    raise RuntimeError(f\"Invalid bool for {name}: {v}\")\n\ndef _get_int_list(name: str, default_csv: str = \"\") -> list[int]:\n    raw = os.getenv(name, default_csv).strip()\n    if not raw:\n        return []\n    out: list[int] = []\n    for part in raw.split(\",\"):\n        part = part.strip()\n        if not part:\n            continue\n        try:\n            out.append(int(part))\n        except ValueError as e:\n            raise RuntimeError(f\"Invalid int in {name}: {part}\") from e\n    return out\n\n@dataclass(frozen=True)\nclass Settings:\n    bot_token: str\n    database_url: str\n    tz: str\n    similarity_ok: int\n    similarity_almost: int\n    learning_steps_minutes: list[int]\n    learning_graduate_days: int\n    import_tmp_dir: str\n\n    subtitle_translate_enabled: bool\n    subtitle_translate_source_lang: str\n    subtitle_translate_target_lang: str\n    translate_concurrency: int\n    translate_min_delay_ms: int\n    translate_max_retries: int\n    translate_base_delay_ms: int\n    translate_max_delay_ms: int\n\n    admin_ids: set[int]\n    upload_secret: str\n    web_host: str\n    web_port: int\n    web_base_url: str\n\ndef load_settings() -> Settings:\n    bot_token = _get_env(\"BOT_TOKEN\")\n\n    database_url = os.getenv(\"DATABASE_URL\")\n    if not database_url:\n        # Default: local SQLite\n        database_url = \"sqlite+aiosqlite:///./bot.db\"\n\n    tz = os.getenv(\"TZ\", \"Europe/Kyiv\")\n    similarity_ok = _get_int(\"SIMILARITY_OK\", 93)\n    similarity_almost = _get_int(\"SIMILARITY_ALMOST\", 85)\n\n    steps_raw = os.getenv(\"LEARNING_STEPS_MINUTES\", \"1,10\")\n    try:\n        learning_steps_minutes = [int(x.strip()) for x in steps_raw.split(\",\") if x.strip()]\n        if not learning_steps_minutes:\n            raise ValueError(\"empty\")\n    except Exception as e:\n        raise RuntimeError(f\"Invalid LEARNING_STEPS_MINUTES: {steps_raw}\") from e\n\n    learning_graduate_days = _get_int(\"LEARNING_GRADUATE_DAYS\", 1)\n    import_tmp_dir = os.getenv(\"IMPORT_TMP_DIR\", \"/tmp/anki_listen_bot_import\")\n\n    subtitle_translate_enabled = _get_bool(\"SUBTITLE_TRANSLATE_ENABLED\", True)\n    subtitle_translate_source_lang = os.getenv(\"SUBTITLE_TRANSLATE_SOURCE_LANG\", \"auto\")\n    subtitle_translate_target_lang = os.getenv(\"SUBTITLE_TRANSLATE_TARGET_LANG\", \"uk\")\n    translate_concurrency = _get_int(\"TRANSLATE_CONCURRENCY\", 1)\n    translate_min_delay_ms = _get_int(\"TRANSLATE_MIN_DELAY_MS\", 250)\n    translate_max_retries = _get_int(\"TRANSLATE_MAX_RETRIES\", 30)\n    translate_base_delay_ms = _get_int(\"TRANSLATE_BASE_DELAY_MS\", 750)\n    translate_max_delay_ms = _get_int(\"TRANSLATE_MAX_DELAY_MS\", 60000)\n\n    admin_ids = set(_get_int_list(\"ADMIN_IDS\", \"\"))\n    upload_secret = _get_env(\"UPLOAD_SECRET\", \"change_me_to_a_long_random_secret\")\n\n    web_host = os.getenv(\"WEB_HOST\", \"0.0.0.0\")\n    web_port = _get_int(\"WEB_PORT\", 8080)\n    web_base_url = os.getenv(\"WEB_BASE_URL\", f\"http://127.0.0.1:{web_port}\")\n\n    return Settings(\n        bot_token=bot_token,\n        database_url=database_url,\n        tz=tz,\n        similarity_ok=similarity_ok,\n        similarity_almost=similarity_almost,\n        learning_steps_minutes=learning_steps_minutes,\n        learning_graduate_days=learning_graduate_days,\n        import_tmp_dir=import_tmp_dir,\n        subtitle_translate_enabled=subtitle_translate_enabled,\n        subtitle_translate_source_lang=subtitle_translate_source_lang,\n        subtitle_translate_target_lang=subtitle_translate_target_lang,\n        translate_concurrency=translate_concurrency,\n        translate_min_delay_ms=translate_min_delay_ms,\n        translate_max_retries=translate_max_retries,\n        translate_base_delay_ms=translate_base_delay_ms,\n        translate_max_delay_ms=translate_max_delay_ms,\n        admin_ids=admin_ids,\n        upload_secret=upload_secret,\n        web_host=web_host,\n        web_port=web_port,\n        web_base_url=web_base_url.rstrip(\"/\"),\n    )\n"
    "content": "from __future__ import annotations\n\nimport secrets\nfrom datetime import datetime\nfrom sqlalchemy import select, update, delete, func\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.db.models import Deck, Card, User, Enrollment, Review, StudySession, Flag, CardTranslation, TranslationCache\n\ndef _new_token() -> str:\n    return secrets.token_urlsafe(18)\n\n# --- Deck ---\nasync def create_deck(session: AsyncSession, admin_tg_id: int, title: str, new_per_day: int) -> Deck:\n    deck = Deck(admin_tg_id=admin_tg_id, title=title[:255], token=_new_token(), new_per_day=new_per_day)\n    session.add(deck)\n    await session.commit()\n    await session.refresh(deck)\n    return deck\n\nasync def get_deck_by_token(session: AsyncSession, token: str) -> Deck | None:\n    res = await session.execute(select(Deck).where(Deck.token == token))\n    return res.scalar_one_or_none()\n\nasync def get_deck_by_id(session: AsyncSession, deck_id: str) -> Deck | None:\n    res = await session.execute(select(Deck).where(Deck.id == deck_id))\n    return res.scalar_one_or_none()\n\nasync def update_deck_new_per_day(session: AsyncSession, deck_id: str, n: int) -> None:\n    await session.execute(update(Deck).where(Deck.id == deck_id).values(new_per_day=n))\n    await session.commit()\n\nasync def rotate_deck_token(session: AsyncSession, deck_id: str) -> str:\n    token = _new_token()\n    await session.execute(update(Deck).where(Deck.id == deck_id).values(token=token))\n    await session.commit()\n    return token\n\nasync def set_deck_active(session: AsyncSession, deck_id: str, active: bool) -> None:\n    await session.execute(update(Deck).where(Deck.id == deck_id).values(is_active=active))\n    await session.commit()\n\nasync def list_admin_decks(session: AsyncSession, admin_tg_id: int) -> list[Deck]:\n    res = await session.execute(select(Deck).where(Deck.admin_tg_id == admin_tg_id).order_by(Deck.created_at.desc()))\n    return list(res.scalars().all())\n\n\nasync def list_all_decks(session: AsyncSession) -> list[Deck]:\n    res = await session.execute(select(Deck).order_by(Deck.created_at.desc()))\n    return list(res.scalars().all())\n\nasync def delete_deck_full(session: AsyncSession, deck_id: str) -> dict[str, int]:\n    \"\"\"Delete deck and all associated data (cards, enrollments, reviews, sessions, flags).\n    Returns counts for basic visibility.\n    \"\"\"\n    # Delete card-linked tables via subquery to avoid SQLite parameter limits.\n    card_ids_subq = select(Card.id).where(Card.deck_id == deck_id)\n\n    res_reviews = await session.execute(delete(Review).where(Review.card_id.in_(card_ids_subq)))\n    res_flags = await session.execute(delete(Flag).where(Flag.card_id.in_(card_ids_subq)))\n    res_card_translations = await session.execute(delete(CardTranslation).where(CardTranslation.card_id.in_(card_ids_subq)))\n\n    res_sessions = await session.execute(delete(StudySession).where(StudySession.deck_id == deck_id))\n    res_enroll = await session.execute(delete(Enrollment).where(Enrollment.deck_id == deck_id))\n\n    res_cards = await session.execute(delete(Card).where(Card.deck_id == deck_id))\n    res_deck = await session.execute(delete(Deck).where(Deck.id == deck_id))\n\n    await session.commit()\n\n    # SQLAlchemy's rowcount may be -1 on some dialects; normalize to 0 in that case.\n    def _rc(x) -> int:\n        try:\n            return int(getattr(x, \"rowcount\", 0) or 0)\n        except Exception:\n            return 0\n\n    return {\n        \"reviews\": _rc(res_reviews),\n        \"flags\": _rc(res_flags),\n        \"card_translations\": _rc(res_card_translations),\n        \"sessions\": _rc(res_sessions),\n        \"enrollments\": _rc(res_enroll),\n        \"cards\": _rc(res_cards),\n        \"decks\": _rc(res_deck),\n    }\n\n# --- Cards ---\nasync def find_file_id_by_sha(session: AsyncSession, sha256: str) -> str | None:\n    res = await session.execute(select(Card.tg_file_id).where(Card.media_sha256 == sha256).limit(1))\n    row = res.first()\n    return row[0] if row else None\n\nasync def insert_cards(session: AsyncSession, deck_id: str, cards: list[Card]) -> tuple[int,int]:\n    ok = 0\n    skipped = 0\n    for c in cards:\n        c.deck_id = deck_id\n        session.add(c)\n        try:\n            await session.flush()\n            ok += 1\n        except IntegrityError:\n            await session.rollback()\n            skipped += 1\n    await session.commit()\n    return ok, skipped\n\nasync def get_card(session: AsyncSession, card_id: str) -> Card | None:\n    res = await session.execute(select(Card).where(Card.id == card_id))\n    return res.scalar_one_or_none()\n\nasync def get_new_cards(session: AsyncSession, deck_id: str, user_id: str, limit: int) -> list[str]:\n    # Cards that have no review row for this user OR review.state == 'new'\n    subq = select(Review.card_id, Review.state).where(Review.user_id == user_id).subquery()\n    stmt = (\n        select(Card.id)\n        .where(Card.deck_id == deck_id, Card.is_valid == True)\n        .where(~Card.id.in_(select(subq.c.card_id).where(subq.c.state == 'suspended')))  # exclude suspended\n        .order_by(Card.created_at.asc())\n        .limit(limit)\n    )\n    res = await session.execute(stmt)\n    card_ids = []\n    for (cid,) in res.all():\n        # if review exists and not 'new', skip\n        r = await session.execute(select(Review).where(Review.user_id==user_id, Review.card_id==cid))\n        rv = r.scalar_one_or_none()\n        if rv is None or rv.state == \"new\":\n            card_ids.append(cid)\n    return card_ids\n\nasync def get_due_learning_cards(session: AsyncSession, user_id: str, deck_id: str, now: datetime, limit: int = 1) -> list[str]:\n    stmt = (\n        select(Review.card_id)\n        .join(Card, Card.id == Review.card_id)\n        .where(\n            Review.user_id == user_id,\n            Card.deck_id == deck_id,\n            Review.state == \"learning\",\n            Review.due_at.is_not(None),\n            Review.due_at <= now,\n        )\n        .order_by(Review.due_at.asc())\n        .limit(limit)\n    )\n    res = await session.execute(stmt)\n    return [cid for (cid,) in res.all()]\n\nasync def get_due_review_cards(session: AsyncSession, user_id: str, deck_id: str, now: datetime, limit: int = 50) -> list[str]:\n    stmt = (\n        select(Review.card_id)\n        .join(Card, Card.id == Review.card_id)\n        .where(\n            Review.user_id == user_id,\n            Card.deck_id == deck_id,\n            Review.state == \"review\",\n            Review.due_at.is_not(None),\n            Review.due_at <= now,\n        )\n        .order_by(Review.due_at.asc())\n        .limit(limit)\n    )\n    res = await session.execute(stmt)\n    return [cid for (cid,) in res.all()]\n\n# --- Users / Enrollment ---\nasync def get_or_create_user(session: AsyncSession, tg_id: int) -> User:\n    res = await session.execute(select(User).where(User.tg_id == tg_id))\n    user = res.scalar_one_or_none()\n    if user:\n        return user\n    user = User(tg_id=tg_id)\n    session.add(user)\n    await session.commit()\n    await session.refresh(user)\n    return user\n\nasync def get_user_by_id(session: AsyncSession, user_id: str) -> User | None:\n    res = await session.execute(select(User).where(User.id == user_id))\n    return res.scalar_one_or_none()\n\nasync def enroll_user(session: AsyncSession, user_id: str, deck_id: str) -> None:\n    enr = Enrollment(user_id=user_id, deck_id=deck_id)\n    session.add(enr)\n    try:\n        await session.commit()\n    except IntegrityError:\n        await session.rollback()\n\nasync def is_enrolled(session: AsyncSession, user_id: str, deck_id: str) -> bool:\n    res = await session.execute(select(Enrollment.id).where(Enrollment.user_id==user_id, Enrollment.deck_id==deck_id))\n    return res.first() is not None\n\nasync def list_enrolled_students(session: AsyncSession, deck_id: str, offset: int = 0, limit: int = 10) -> list[User]:\n    stmt = (\n        select(User)\n        .join(Enrollment, Enrollment.user_id == User.id)\n        .where(Enrollment.deck_id == deck_id)\n        .order_by(Enrollment.joined_at.asc())\n        .offset(offset)\n        .limit(limit)\n    )\n    res = await session.execute(stmt)\n    return list(res.scalars().all())\n\nasync def count_enrolled_students(session: AsyncSession, deck_id: str) -> int:\n    res = await session.execute(select(func.count(Enrollment.id)).where(Enrollment.deck_id == deck_id))\n    return int(res.scalar() or 0)\n\n# --- Reviews ---\nasync def get_review(session: AsyncSession, user_id: str, card_id: str) -> Review | None:\n    res = await session.execute(select(Review).where(Review.user_id==user_id, Review.card_id==card_id))\n    return res.scalar_one_or_none()\n\nasync def upsert_review(session: AsyncSession, review: Review) -> None:\n    session.add(review)\n    await session.commit()\n\nasync def get_due_cards(session: AsyncSession, user_id: str, deck_id: str, now: datetime) -> list[str]:\n    # Join reviews -> cards to filter deck\n    stmt = (\n        select(Review.card_id)\n        .join(Card, Card.id == Review.card_id)\n        .where(\n            Review.user_id == user_id,\n            Card.deck_id == deck_id,\n            Review.state.in_([\"learning\",\"review\"]),\n            Review.due_at.is_not(None),\n            Review.due_at <= now\n        )\n        .order_by(Review.due_at.asc())\n    )\n    res = await session.execute(stmt)\n    return [cid for (cid,) in res.all()]\n\n# --- Study Sessions ---\nasync def get_today_session(session: AsyncSession, user_id: str, deck_id: str, study_date) -> StudySession | None:\n    res = await session.execute(\n        select(StudySession).where(\n            StudySession.user_id==user_id,\n            StudySession.deck_id==deck_id,\n            StudySession.study_date==study_date\n        )\n    )\n    return res.scalar_one_or_none()\n\nasync def get_study_sessions_for_user_deck_in_range(session: AsyncSession, user_id: str, deck_id: str, date_from, date_to) -> list[StudySession]:\n    stmt = (\n        select(StudySession)\n        .where(\n            StudySession.user_id == user_id,\n            StudySession.deck_id == deck_id,\n            StudySession.study_date >= date_from,\n            StudySession.study_date <= date_to,\n        )\n        .order_by(StudySession.study_date.asc())\n    )\n    res = await session.execute(stmt)\n    return list(res.scalars().all())\n\nasync def create_today_session(session: AsyncSession, user_id: str, deck_id: str, study_date, queue: list[str]) -> StudySession:\n    s = StudySession(\n        user_id=user_id,\n        deck_id=deck_id,\n        study_date=study_date,\n        queue=queue,\n        pos=0,\n        current_card_id=None,\n        updated_at=datetime.utcnow(),\n    )\n    session.add(s)\n    try:\n        await session.commit()\n    except IntegrityError:\n        await session.rollback()\n        # someone created it concurrently, fetch\n        existing = await get_today_session(session, user_id, deck_id, study_date)\n        if existing:\n            return existing\n        raise\n    await session.refresh(s)\n    return s\n\nasync def update_session_progress(session: AsyncSession, session_id: str, pos: int, current_card_id: str | None) -> None:\n    await session.execute(\n        update(StudySession)\n        .where(StudySession.id == session_id)\n        .values(pos=pos, current_card_id=current_card_id, updated_at=datetime.utcnow())\n    )\n    await session.commit()\n\nasync def update_session_queue(session: AsyncSession, session_id: str, queue: list[str], current_card_id: str | None) -> None:\n    await session.execute(\n        update(StudySession)\n        .where(StudySession.id == session_id)\n        .values(queue=queue, current_card_id=current_card_id, updated_at=datetime.utcnow())\n    )\n    await session.commit()\n\nasync def claim_current_if_none(session: AsyncSession, session_id: str, card_id: str) -> bool:\n    res = await session.execute(\n        update(StudySession)\n        .where(StudySession.id == session_id, StudySession.current_card_id.is_(None))\n        .values(current_card_id=card_id, updated_at=datetime.utcnow())\n        .returning(StudySession.id)\n    )\n    row = res.first()\n    await session.commit()\n    return row is not None\n\n# --- Flags ---\nasync def add_flag(session: AsyncSession, user_id: str, card_id: str, reason: str=\"bad_card\") -> None:\n    session.add(Flag(user_id=user_id, card_id=card_id, reason=reason))\n    await session.commit()\n\nasync def export_flags(session: AsyncSession, deck_id: str) -> list[tuple[str,str,int]]:\n    # returns (note_guid, answer_text, count)\n    stmt = (\n        select(Card.note_guid, Card.answer_text, func.count(Flag.id))\n        .join(Flag, Flag.card_id == Card.id)\n        .where(Card.deck_id == deck_id)\n        .group_by(Card.note_guid, Card.answer_text)\n        .order_by(func.count(Flag.id).desc())\n        .limit(200)\n    )\n    res = await session.execute(stmt)\n    return [(a,b,int(c)) for (a,b,c) in res.all()]\n\n\n# --- Admin progress helpers ---\nasync def compute_overall_progress(session: AsyncSession, user_id: str, deck_id: str, now: datetime | None = None) -> dict:\n    \"\"\"Return deck-level progress summary for a user.\"\"\"\n    now = now or datetime.utcnow()\n    total_cards_res = await session.execute(select(func.count(Card.id)).where(Card.deck_id == deck_id))\n    total_cards = int(total_cards_res.scalar() or 0)\n\n    state_rows = await session.execute(\n        select(Review.state, func.count(Review.card_id))\n        .join(Card, Card.id == Review.card_id)\n        .where(Review.user_id == user_id, Card.deck_id == deck_id)\n        .group_by(Review.state)\n    )\n    state_counts = {state: int(count) for state, count in state_rows.all()}\n    started = sum(state_counts.values())\n\n    due_res = await session.execute(\n        select(func.count(Review.card_id))\n        .join(Card, Card.id == Review.card_id)\n        .where(\n            Review.user_id == user_id,\n            Card.deck_id == deck_id,\n            Review.state.in_([\"learning\", \"review\"]),\n            Review.due_at.is_not(None),\n            Review.due_at <= now,\n        )\n    )\n    due_count = int(due_res.scalar() or 0)\n\n    return {\n        \"total_cards\": total_cards,\n        \"started\": started,\n        \"states\": state_counts,\n        \"due\": due_count,\n    }\n\n\n# --- Unenroll helpers ---\nasync def unenroll_student_wipe_progress(session: AsyncSession, user_id: str, deck_id: str) -> None:\n    card_ids_subq = select(Card.id).where(Card.deck_id == deck_id)\n    async with session.begin():\n        await session.execute(\n            delete(StudySession).where(\n                StudySession.user_id == user_id,\n                StudySession.deck_id == deck_id,\n            )\n        )\n        await session.execute(\n            delete(Flag).where(\n                Flag.user_id == user_id,\n                Flag.card_id.in_(card_ids_subq),\n            )\n        )\n        await session.execute(\n            delete(Review).where(\n                Review.user_id == user_id,\n                Review.card_id.in_(card_ids_subq),\n            )\n        )\n        await session.execute(\n            delete(Enrollment).where(\n                Enrollment.user_id == user_id,\n                Enrollment.deck_id == deck_id,\n            )\n        )\n\nasync def unenroll_all_students_wipe_progress(session: AsyncSession, deck_id: str) -> None:\n    card_ids_subq = select(Card.id).where(Card.deck_id == deck_id)\n    async with session.begin():\n        await session.execute(delete(StudySession).where(StudySession.deck_id == deck_id))\n        await session.execute(delete(Flag).where(Flag.card_id.in_(card_ids_subq)))\n        await session.execute(delete(Review).where(Review.card_id.in_(card_ids_subq)))\n        await session.execute(delete(Enrollment).where(Enrollment.deck_id == deck_id))\n\n\n# --- Translations ---\nasync def get_card_translation_uk(session: AsyncSession, card_id: str) -> str | None:\n    \"\"\"Returns Ukrainian subtitle translation for a card, if available.\"\"\"\n    stmt = (\n        select(TranslationCache.translated_text)\n        .join(CardTranslation, CardTranslation.cache_key == TranslationCache.key)\n        .where(CardTranslation.card_id == card_id)\n        .limit(1)\n    )\n    res = await session.execute(stmt)\n    row = res.first()\n    return row[0] if row else None\n"
    "path": "app/handlers/__init__.py",
    "content": ""
    "path": "app/handlers/admin_import.py",
    "content": "from __future__ import annotations\n\nimport os\nimport uuid\n\nfrom aiogram import Router, F, Bot\nfrom aiogram.types import Message\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.bot.messages import admin_import_prompt, ask_new_per_day, invalid_number, deck_link\nfrom app.bot.keyboards import kb_admin_deck\nfrom app.db.repo import update_deck_new_per_day, get_deck_by_id\nfrom app.services.import_service import import_apkg_from_path\n\nrouter = Router()\n\nclass ImportFSM(StatesGroup):\n    waiting_new_per_day = State()\n\n@router.message(F.document)\nasync def on_apkg(message: Message, bot: Bot, session: AsyncSession, settings, state: FSMContext, bot_username: str):\n    doc = message.document\n    if not doc.file_name or not doc.file_name.lower().endswith(\".apkg\"):\n        return\n\n    # Admin-only\n    if settings.admin_ids and message.from_user.id not in settings.admin_ids:\n        await message.answer(\"Not allowed.\")\n        return\n\n    await message.answer(admin_import_prompt())\n\n    # download file (Telegram size limit applies)\n    file = await bot.get_file(doc.file_id)\n    os.makedirs(settings.import_tmp_dir, exist_ok=True)\n    local_path = os.path.join(settings.import_tmp_dir, f\"tg_{uuid.uuid4().hex}.apkg\")\n    await bot.download_file(file.file_path, destination=local_path)\n\n    # store temp path in FSM; import after new_per_day to keep previous flow\n    await state.update_data(apkg_path=local_path, deck_title=(doc.file_name or \"Deck\"))\n    await state.set_state(ImportFSM.waiting_new_per_day)\n    await message.answer(ask_new_per_day())\n\n@router.message(ImportFSM.waiting_new_per_day, F.text)\nasync def on_new_per_day(message: Message, settings, state: FSMContext, bot: Bot, bot_username: str, sessionmaker):\n    # Admin-only\n    if settings.admin_ids and message.from_user.id not in settings.admin_ids:\n        await message.answer(\"Not allowed.\")\n        await state.clear()\n        return\n\n    try:\n        n = int(message.text.strip())\n        if n <= 0 or n > 500:\n            raise ValueError()\n    except ValueError:\n        await message.answer(invalid_number())\n        return\n\n    data = await state.get_data()\n    apkg_path = data.get(\"apkg_path\")\n    deck_title = data.get(\"deck_title\") or \"Deck\"\n    if not apkg_path:\n        await message.answer(\"Import context lost. Upload the deck again.\")\n        await state.clear()\n        return\n\n    # Import now\n    res = await import_apkg_from_path(\n        settings=settings,\n        bot=bot,\n        bot_username=bot_username,\n        sessionmaker=sessionmaker,\n        admin_tg_id=message.from_user.id,\n        apkg_path=str(apkg_path),\n        deck_title=deck_title,\n        new_per_day=n,\n    )\n\n    await message.answer(f\"Imported: {res['imported']}, skipped: {res['skipped']}\\nLink: {res['link']}\")\n    await state.clear()\n\n    try:\n        os.remove(apkg_path)\n    except Exception:\n        pass\n"
    "path": "app/handlers/admin_manage.py",
    "content": "from __future__ import annotations\n\nfrom aiogram import Router, F\nfrom aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.bot.keyboards import kb_admin_deck, kb_admin_deck_list\nfrom app.bot.messages import deck_link, invalid_number\nfrom app.db.repo import get_deck_by_id, export_flags, rotate_deck_token, set_deck_active, update_deck_new_per_day, list_admin_decks, list_all_decks, delete_deck_full\nfrom app.services.stats_service import admin_stats\n\nrouter = Router()\n\nclass AdminSetN(StatesGroup):\n    waiting = State()\n\n@router.callback_query(F.data.startswith(\"ad_stats:\"))\nasync def cb_ad_stats(call: CallbackQuery, session: AsyncSession):\n    deck_id = call.data.split(\":\",1)[1]\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck or deck.admin_tg_id != call.from_user.id:\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n    txt = await admin_stats(session, deck_id)\n    await call.message.answer(txt, reply_markup=kb_admin_deck(deck_id))\n    await call.answer()\n\n@router.callback_query(F.data.startswith(\"ad_export:\"))\nasync def cb_ad_export(call: CallbackQuery, session: AsyncSession):\n    deck_id = call.data.split(\":\",1)[1]\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck or deck.admin_tg_id != call.from_user.id:\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n    rows = await export_flags(session, deck_id)\n    if not rows:\n        await call.message.answer(\"No bad cards flagged yet.\", reply_markup=kb_admin_deck(deck_id))\n        await call.answer()\n        return\n    lines = [\"note_guid,flags,answer\"]\n    for guid, ans, cnt in rows:\n        ans_clean = ans.replace(\"\\n\",\" \").replace(\",\",\";\")\n        lines.append(f\"{guid},{cnt},{ans_clean}\")\n    text = \"\\n\".join(lines)\n    # split if needed\n    for chunk_start in range(0, len(text), 3500):\n        await call.message.answer(text[chunk_start:chunk_start+3500])\n    await call.message.answer(\"Export done.\", reply_markup=kb_admin_deck(deck_id))\n    await call.answer()\n\n@router.callback_query(F.data.startswith(\"ad_rot:\"))\nasync def cb_ad_rotate(call: CallbackQuery, session: AsyncSession, bot_username: str):\n    deck_id = call.data.split(\":\",1)[1]\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck or deck.admin_tg_id != call.from_user.id:\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n    token = await rotate_deck_token(session, deck_id)\n    link = deck_link(bot_username, token)\n    await call.message.answer(f\"New link: {link}\", reply_markup=kb_admin_deck(deck_id))\n    await call.answer()\n\n@router.callback_query(F.data.startswith(\"ad_dis:\"))\nasync def cb_ad_disable(call: CallbackQuery, session: AsyncSession):\n    deck_id = call.data.split(\":\",1)[1]\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck or deck.admin_tg_id != call.from_user.id:\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n    await set_deck_active(session, deck_id, False)\n    await call.message.answer(\"Deck disabled.\")\n    await call.answer()\n\n@router.callback_query(F.data.startswith(\"ad_setn:\"))\nasync def cb_ad_setn(call: CallbackQuery, state: FSMContext):\n    deck_id = call.data.split(\":\",1)[1]\n    await state.update_data(deck_id=deck_id)\n    await state.set_state(AdminSetN.waiting)\n    await call.message.answer(\"Send new N/day (integer).\")\n    await call.answer()\n\n@router.message(AdminSetN.waiting, F.text)\nasync def on_admin_setn(message: Message, session: AsyncSession, state: FSMContext):\n    try:\n        n = int(message.text.strip())\n        if n <= 0 or n > 500:\n            raise ValueError()\n    except ValueError:\n        await message.answer(invalid_number())\n        return\n    data = await state.get_data()\n    deck_id = data.get(\"deck_id\")\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck or deck.admin_tg_id != message.from_user.id:\n        await message.answer(\"Not allowed.\")\n        await state.clear()\n        return\n    await update_deck_new_per_day(session, deck_id, n)\n    await message.answer(f\"N/day updated to {n}.\", reply_markup=kb_admin_deck(deck_id))\n    await state.clear()\n\n\ndef _is_admin(settings, tg_id: int) -> bool:\n    return (not settings.admin_ids) or (tg_id in settings.admin_ids)\n\n@router.callback_query(F.data == \"ad_list\")\nasync def cb_ad_list(call: CallbackQuery, session: AsyncSession, settings):\n    if not _is_admin(settings, call.from_user.id):\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n\n    # If ADMIN_IDS is set, treat them as global admins -> show all decks.\n    if settings.admin_ids:\n        decks = await list_all_decks(session)\n    else:\n        decks = await list_admin_decks(session, call.from_user.id)\n\n    items = [(d.id, d.title, bool(d.is_active)) for d in decks]\n    if not items:\n        await call.message.answer(\"No decks yet.\")\n        await call.answer()\n        return\n\n    await call.message.answer(\"Decks:\", reply_markup=kb_admin_deck_list(items))\n    await call.answer()\n\n@router.callback_query(F.data.startswith(\"ad_open:\"))\nasync def cb_ad_open(call: CallbackQuery, session: AsyncSession, bot_username: str, settings):\n    if not _is_admin(settings, call.from_user.id):\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n    deck_id = call.data.split(\":\", 1)[1]\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck:\n        await call.answer(\"Deck not found\", show_alert=True)\n        return\n    # If ADMIN_IDS is empty, restrict to deck owner.\n    if not settings.admin_ids and deck.admin_tg_id != call.from_user.id:\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n    link = deck_link(bot_username, deck.token)\n    await call.message.answer(f\"{deck.title}\\n{link}\", reply_markup=kb_admin_deck(deck_id))\n    await call.answer()\n\n@router.callback_query(F.data == \"ad_close\")\nasync def cb_ad_close(call: CallbackQuery):\n    try:\n        await call.message.delete()\n    except Exception:\n        pass\n    await call.answer()\n\n@router.callback_query(F.data.startswith(\"ad_del:\"))\nasync def cb_ad_delete_confirm(call: CallbackQuery, session: AsyncSession, settings):\n    if not _is_admin(settings, call.from_user.id):\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n    deck_id = call.data.split(\":\", 1)[1]\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck:\n        await call.answer(\"Deck not found\", show_alert=True)\n        return\n    if not settings.admin_ids and deck.admin_tg_id != call.from_user.id:\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n\n    await call.message.answer(\n        f\"Delete deck '{deck.title}'?\\nThis will remove all cards, enrollments, reviews, study sessions and flags.\",\n        reply_markup=InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"Confirm delete\", callback_data=f\"ad_del2:{deck_id}\")],\n            [InlineKeyboardButton(text=\"Cancel\", callback_data=\"ad_list\")],\n        ]),\n    )\n    await call.answer()\n\n@router.callback_query(F.data.startswith(\"ad_del2:\"))\nasync def cb_ad_delete_do(call: CallbackQuery, session: AsyncSession, settings):\n    if not _is_admin(settings, call.from_user.id):\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n    deck_id = call.data.split(\":\", 1)[1]\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck:\n        await call.answer(\"Deck not found\", show_alert=True)\n        return\n    if not settings.admin_ids and deck.admin_tg_id != call.from_user.id:\n        await call.answer(\"Not allowed\", show_alert=True)\n        return\n\n    counts = await delete_deck_full(session, deck_id)\n    await call.message.answer(f\"Deck deleted. (cards={counts.get('cards',0)}, enrollments={counts.get('enrollments',0)})\")\n    await call.answer()\n\n"
    "path": "app/handlers/admin_students.py",
    "content": "from __future__ import annotations\n\nfrom aiogram import Router, F, Bot\nfrom aiogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.db.repo import (\n    count_enrolled_students,\n    get_deck_by_id,\n    get_user_by_id,\n    list_enrolled_students,\n    unenroll_all_students_wipe_progress,\n    unenroll_student_wipe_progress,\n)\nfrom app.services.student_progress import (\n    get_daily_progress_history,\n    get_overall_progress_summary,\n    get_today_progress,\n)\nfrom app.utils.timez import now_tz, today_date\n\nrouter = Router()\n\nPAGE_SIZE = 10\n\n\ndef _is_admin(settings, tg_id: int) -> bool:\n    return (not settings.admin_ids) or (tg_id in settings.admin_ids)\n\n\nasync def _ensure_deck_admin(call: CallbackQuery, session: AsyncSession, settings, deck_id: str):\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck:\n        await call.answer(\"Deck not found\", show_alert=True)\n        return None\n    if not _is_admin(settings, call.from_user.id) and deck.admin_tg_id != call.from_user.id:\n        await call.answer(\"Not allowed\", show_alert=True)\n        return None\n    return deck\n\n\nasync def _display_user(bot: Bot, tg_id: int) -> tuple[str, str | None]:\n    try:\n        chat = await bot.get_chat(tg_id)\n        parts = [chat.first_name or \"\", chat.last_name or \"\"]\n        full_name = \" \".join(p for p in parts if p).strip()\n        username = chat.username\n        if username and not full_name:\n            full_name = f\"@{username}\"\n        if not full_name:\n            full_name = f\"User {tg_id}\"\n        return full_name, username\n    except Exception:\n        return f\"User {tg_id}\", None\n\n\nasync def _student_list_text(bot: Bot, session: AsyncSession, deck_title: str, deck_id: str, settings, page: int):\n    total = await count_enrolled_students(session, deck_id)\n    if total == 0:\n        text = f\"{deck_title}\\nNo students enrolled yet.\"\n        return text, InlineKeyboardMarkup(\n            inline_keyboard=[[InlineKeyboardButton(text=\"Back\", callback_data=f\"ad_open:{deck_id}\")]]\n        )\n\n    today = today_date(settings.tz)\n    start = page * PAGE_SIZE\n    students = await list_enrolled_students(session, deck_id, offset=start, limit=PAGE_SIZE)\n    total_pages = (total + PAGE_SIZE - 1) // PAGE_SIZE\n    lines = [f\"Students for {deck_title}\", f\"Page {page + 1}/{total_pages}\"]\n    buttons: list[list[InlineKeyboardButton]] = []\n    for user in students:\n        name, _ = await _display_user(bot, user.tg_id)\n        today_done, today_total = await get_today_progress(session, user.id, deck_id, today)\n        overall = await get_overall_progress_summary(session, user.id, deck_id)\n        overall_summary = f\"{overall['started']}/{overall['total_cards']} started\"\n        lines.append(f\"\u2022 {name}: today {today_done}/{today_total}, {overall_summary}\")\n        buttons.append(\n            [\n                InlineKeyboardButton(\n                    text=f\"{name} ({today_done}/{today_total} today)\",\n                    callback_data=f\"ad_student:{deck_id}:{user.id}:{page}\",\n                )\n            ]\n        )\n\n    nav_row = []\n    if page > 0:\n        nav_row.append(InlineKeyboardButton(text=\"\u2b05\ufe0f Prev\", callback_data=f\"ad_students:{deck_id}:{page - 1}\"))\n    if start + len(students) < total:\n        nav_row.append(InlineKeyboardButton(text=\"Next \u27a1\ufe0f\", callback_data=f\"ad_students:{deck_id}:{page + 1}\"))\n    if nav_row:\n        buttons.append(nav_row)\n\n    buttons.append([InlineKeyboardButton(text=\"Back\", callback_data=f\"ad_open:{deck_id}\")])\n    kb = InlineKeyboardMarkup(inline_keyboard=buttons)\n    return \"\\n\".join(lines), kb\n\n\n@router.callback_query(F.data.startswith(\"ad_students:\"))\nasync def cb_ad_student_list(call: CallbackQuery, session: AsyncSession, bot: Bot, settings):\n    _, deck_id, *rest = call.data.split(\":\", 2)\n    page = int(rest[0]) if rest else 0\n    deck = await _ensure_deck_admin(call, session, settings, deck_id)\n    if not deck:\n        return\n    text, kb = await _student_list_text(bot, session, deck.title, deck_id, settings, page)\n    await call.message.answer(text, reply_markup=kb)\n    await call.answer()\n\n\ndef _format_history(history: list[tuple]) -> str:\n    lines = []\n    for dt, done, total in history:\n        lines.append(f\"{dt}: {done}/{total}\")\n    return \"\\n\".join(lines)\n\n\ndef _format_overall(overall: dict) -> str:\n    states = overall.get(\"states\", {})\n    parts = [f\"Total cards: {overall.get('total_cards', 0)}\"]\n    parts.append(f\"Started: {overall.get('started', 0)}\")\n    if states:\n        state_line = \", \".join(f\"{k}: {v}\" for k, v in states.items())\n        parts.append(f\"States: {state_line}\")\n    due = overall.get(\"due\")\n    if due is not None:\n        parts.append(f\"Due now: {due}\")\n    return \"\\n\".join(parts)\n\n\n@router.callback_query(F.data.startswith(\"ad_student:\"))\nasync def cb_ad_student_detail(call: CallbackQuery, session: AsyncSession, bot: Bot, settings):\n    _, deck_id, user_id, *rest = call.data.split(\":\", 3)\n    page = int(rest[0]) if rest else 0\n    deck = await _ensure_deck_admin(call, session, settings, deck_id)\n    if not deck:\n        return\n\n    user = await get_user_by_id(session, user_id)\n    if not user:\n        await call.answer(\"Student not found\", show_alert=True)\n        return\n\n    name, username = await _display_user(bot, user.tg_id)\n    today = today_date(settings.tz)\n    today_done, today_total = await get_today_progress(session, user.id, deck_id, today)\n    history = await get_daily_progress_history(session, user.id, deck_id, today, days=7)\n    overall = await get_overall_progress_summary(session, user.id, deck_id, now=now_tz(settings.tz))\n\n    lines = [f\"Deck: {deck.title}\"]\n    identity = f\"Student: {name} (tg_id={user.tg_id})\"\n    if username:\n        identity += f\" @{username}\"\n    lines.append(identity)\n    lines.append(\"\")\n    lines.append(f\"Today: {today_done}/{today_total}\")\n    lines.append(\"Last 7 days:\")\n    lines.append(_format_history(history))\n    lines.append(\"\")\n    lines.append(\"Overall:\")\n    lines.append(_format_overall(overall))\n\n    kb = InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=\"Unenroll student\", callback_data=f\"ad_unenroll:{deck_id}:{user_id}\")],\n            [InlineKeyboardButton(text=\"Back\", callback_data=f\"ad_students:{deck_id}:{page}\")],\n        ]\n    )\n    await call.message.answer(\"\\n\".join(lines), reply_markup=kb)\n    await call.answer()\n\n\n@router.callback_query(F.data.startswith(\"ad_unenroll:\"))\nasync def cb_ad_unenroll_confirm(call: CallbackQuery, session: AsyncSession, settings):\n    _, deck_id, user_id = call.data.split(\":\", 2)\n    deck = await _ensure_deck_admin(call, session, settings, deck_id)\n    if not deck:\n        return\n    text = (\n        \"Unenroll this student?\\n\"\n        \"This will remove enrollment and delete all progress for this deck.\"\n    )\n    kb = InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=\"Confirm\", callback_data=f\"ad_unenroll2:{deck_id}:{user_id}\")],\n            [InlineKeyboardButton(text=\"Cancel\", callback_data=f\"ad_students:{deck_id}:0\")],\n        ]\n    )\n    await call.message.answer(text, reply_markup=kb)\n    await call.answer()\n\n\n@router.callback_query(F.data.startswith(\"ad_unenroll2:\"))\nasync def cb_ad_unenroll_do(call: CallbackQuery, session: AsyncSession, bot: Bot, settings):\n    _, deck_id, user_id = call.data.split(\":\", 2)\n    deck = await _ensure_deck_admin(call, session, settings, deck_id)\n    if not deck:\n        return\n    await unenroll_student_wipe_progress(session, user_id, deck_id)\n    text, kb = await _student_list_text(bot, session, deck.title, deck_id, settings, 0)\n    await call.message.answer(\"Student unenrolled and progress erased.\")\n    await call.message.answer(text, reply_markup=kb)\n    await call.answer()\n\n\n@router.callback_query(F.data.startswith(\"ad_unenroll_all:\"))\nasync def cb_ad_unenroll_all_confirm(call: CallbackQuery, session: AsyncSession, settings):\n    deck_id = call.data.split(\":\", 1)[1]\n    deck = await _ensure_deck_admin(call, session, settings, deck_id)\n    if not deck:\n        return\n    text = (\n        \"Unenroll EVERYONE from this deck?\\n\"\n        \"This will remove enrollment and delete all progress for this deck.\"\n    )\n    kb = InlineKeyboardMarkup(\n        inline_keyboard=[\n            [InlineKeyboardButton(text=\"Confirm\", callback_data=f\"ad_unenroll_all2:{deck_id}\")],\n            [InlineKeyboardButton(text=\"Cancel\", callback_data=f\"ad_open:{deck_id}\")],\n        ]\n    )\n    await call.message.answer(text, reply_markup=kb)\n    await call.answer()\n\n\n@router.callback_query(F.data.startswith(\"ad_unenroll_all2:\"))\nasync def cb_ad_unenroll_all_do(call: CallbackQuery, session: AsyncSession, bot: Bot, settings):\n    deck_id = call.data.split(\":\", 1)[1]\n    deck = await _ensure_deck_admin(call, session, settings, deck_id)\n    if not deck:\n        return\n    await unenroll_all_students_wipe_progress(session, deck_id)\n    text, kb = await _student_list_text(bot, session, deck.title, deck_id, settings, 0)\n    await call.message.answer(\"All students unenrolled and progress erased.\")\n    await call.message.answer(text, reply_markup=kb)\n    await call.answer()\n"
    "path": "app/handlers/callbacks.py",
    "content": "from __future__ import annotations\n\nfrom datetime import datetime\n\nfrom aiogram import Router, F, Bot\nfrom aiogram.types import CallbackQuery\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\nfrom app.utils.locks import LockRegistry\nfrom app.utils.timez import today_date\nfrom app.bot.messages import flagged_bad, done_today, need_today_first\nfrom app.bot.keyboards import kb_study_more\nfrom app.db.repo import get_or_create_user, get_today_session, get_card\nfrom app.db.models import StudySession\nfrom app.services.flag_service import flag_bad_card\nfrom app.services.study_engine import ensure_current_card, record_answered_card\nfrom app.services.card_sender import send_card_to_chat\n\nrouter = Router()\n\n\n@router.callback_query(F.data.startswith(\"bad:\"))\nasync def cb_bad_card(call: CallbackQuery, session: AsyncSession, settings, locks: LockRegistry, bot: Bot):\n    # bad:<card_id>\n    parts = call.data.split(\":\", 1)\n    if len(parts) != 2:\n        await call.answer()\n        return\n    card_id = parts[1]\n\n    user = await get_or_create_user(session, call.from_user.id)\n\n    sdate = today_date(settings.tz)\n    # find most recent active session today (deck inferred)\n    res = await session.execute(\n        select(StudySession)\n        .where(StudySession.user_id == user.id, StudySession.study_date == sdate, StudySession.current_card_id.is_not(None))\n        .order_by(StudySession.updated_at.desc())\n        .limit(1)\n    )\n    sess = res.scalar_one_or_none()\n    if not sess:\n        await call.message.answer(need_today_first())\n        await call.answer()\n        return\n\n    deck_id = sess.deck_id\n    lock = locks.lock((user.id, deck_id))\n\n    async with lock:\n        await flag_bad_card(session, user.id, card_id)\n        await call.message.answer(flagged_bad())\n\n        sess2 = await get_today_session(session, user.id, deck_id, sdate)\n        if not sess2:\n            await call.message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            await call.answer()\n            return\n\n        await record_answered_card(session, sess2, card_id)\n        next_id = await ensure_current_card(session, user.id, deck_id, sdate, datetime.utcnow())\n        if not next_id:\n            await call.message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            await call.answer()\n            return\n        next_card = await get_card(session, next_id)\n        if not next_card:\n            await call.message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            await call.answer()\n            return\n        await send_card_to_chat(bot, call.message.chat.id, next_card, deck_id)\n        await call.answer()\n"
    "path": "app/handlers/common.py",
    "content": "from __future__ import annotations\n\nfrom aiogram import Router\nfrom aiogram.filters import CommandStart, Command\nfrom aiogram.types import Message\nfrom aiogram.fsm.context import FSMContext\n\nfrom app.bot.messages import start_message\nfrom app.bot.keyboards import kb_admin_home\n\nrouter = Router()\n\ndef _get_start_payload(message: Message) -> str:\n    if not message.text:\n        return \"\"\n    parts = message.text.split(maxsplit=1)\n    return parts[1].strip() if len(parts) > 1 else \"\"\n\n@router.message(CommandStart())\nasync def cmd_start(message: Message, state: FSMContext, settings, bot_username: str):\n    # Deep-link /start payloads are handled elsewhere\n    if _get_start_payload(message):\n        return\n\n    # Admin menu (if ADMIN_IDS set; if empty -> everyone is admin)\n    is_admin = (not settings.admin_ids) or (message.from_user.id in settings.admin_ids)\n    if is_admin:\n        await message.answer(start_message(), reply_markup=kb_admin_home(settings, message.from_user.id))\n        return\n\n    await message.answer(start_message())\n\n@router.message(Command(\"help\"))\nasync def cmd_help(message: Message):\n    await message.answer(start_message())\n"
    "path": "app/handlers/student_join.py",
    "content": "from __future__ import annotations\n\nfrom datetime import datetime\n\nfrom aiogram import Router, Bot\nfrom aiogram.filters import CommandStart\nfrom aiogram.types import Message\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.services.token_service import parse_payload\nfrom app.bot.messages import deck_not_found, deck_inactive, done_today\nfrom app.bot.keyboards import kb_study_more\nfrom app.db.repo import get_deck_by_token, get_or_create_user, enroll_user, get_card\nfrom app.utils.locks import LockRegistry\nfrom app.utils.timez import today_date\nfrom app.services.study_engine import ensure_current_card, start_or_resume_today\nfrom app.services.card_sender import send_card_to_chat\n\nrouter = Router()\n\n@router.message(CommandStart(deep_link=True))\nasync def start_with_payload(message: Message, session: AsyncSession, settings, locks: LockRegistry, bot: Bot):\n    payload = message.text.split(maxsplit=1)[1] if message.text and len(message.text.split()) > 1 else None\n    token = parse_payload(payload)\n    if not token:\n        await message.answer(deck_not_found())\n        return\n\n    deck = await get_deck_by_token(session, token)\n    if not deck:\n        await message.answer(deck_not_found())\n        return\n\n    # Read required fields BEFORE any commit to avoid async lazy-load issues.\n    deck_id = deck.id\n    is_active = deck.is_active\n\n    if not is_active:\n        await message.answer(deck_inactive())\n        return\n\n    user = await get_or_create_user(session, message.from_user.id)\n    # IMPORTANT: capture primitive IDs before enroll_user().\n    # enroll_user() may hit IntegrityError (already enrolled) and perform rollback(),\n    # which expires ORM objects; accessing user.id after rollback can trigger async\n    # lazy-loading and crash with MissingGreenlet.\n    user_id = user.id\n    await enroll_user(session, user_id, deck_id)\n\n    lock = locks.lock((user_id, deck_id))\n    async with lock:\n        now_utc = datetime.utcnow()\n        sdate = today_date(settings.tz)\n        sess, _created = await start_or_resume_today(session, user_id, deck_id, sdate, now_utc)\n        cid = await ensure_current_card(session, user_id, deck_id, sdate, now_utc)\n\n        if not getattr(sess, \"queue\", None) or not cid:\n            await message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            return\n\n        card = await get_card(session, cid)\n        if not card:\n            await message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            return\n\n        # Minimal UX: send the card immediately (no extra menus).\n        await send_card_to_chat(bot, message.chat.id, card, deck_id)\n"
    "path": "app/handlers/student_study.py",
    "content": "from __future__ import annotations\n\nimport asyncio\nfrom datetime import datetime\n\nfrom aiogram import Router, F\nfrom aiogram.types import CallbackQuery, Message\nfrom aiogram import Bot\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\nfrom app.utils.locks import LockRegistry\nfrom app.utils.timez import today_date\nfrom app.bot.messages import no_cards_today, done_today, need_today_first\nfrom app.bot.keyboards import kb_bad_card, kb_study_more\nfrom app.db.repo import get_or_create_user, get_deck_by_id, is_enrolled, get_card, get_review, upsert_review, get_today_session, get_card_translation_uk\nfrom app.db.models import StudySession\nfrom app.services.study_engine import ensure_current_card, extend_today_with_more, record_answered_card, start_or_resume_today\nfrom app.services.grader import grade\nfrom app.services.comparer import format_compare\nfrom app.services.srs import apply_srs\nfrom app.services.card_sender import send_card_to_chat\n\nrouter = Router()\n\n\nasync def _send_card(bot: Bot, chat_id: int, card, deck_id: str):\n    await send_card_to_chat(bot, chat_id, card, deck_id)\n\n\n@router.callback_query(F.data.startswith(\"more:\"))\nasync def cb_more(call: CallbackQuery, session: AsyncSession, settings, locks: LockRegistry, bot: Bot):\n    deck_id = call.data.split(\":\", 1)[1]\n    user = await get_or_create_user(session, call.from_user.id)\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck or not deck.is_active:\n        await call.message.answer(\"Deck inactive or not found.\")\n        await call.answer()\n        return\n    if not await is_enrolled(session, user.id, deck_id):\n        await call.message.answer(\"Not enrolled. Open the deck link again.\")\n        await call.answer()\n        return\n\n    lock = locks.lock((user.id, deck_id))\n    async with lock:\n        now_utc = datetime.utcnow()\n        sdate = today_date(settings.tz)\n\n        sess = await get_today_session(session, user.id, deck_id, sdate)\n        if not sess:\n            sess, _ = await start_or_resume_today(session, user.id, deck_id, sdate, now_utc)\n\n        cid = await ensure_current_card(session, user.id, deck_id, sdate, now_utc)\n        if not cid:\n            # try extending queue with more work\n            sess = await extend_today_with_more(session, user.id, deck_id, sdate, now_utc, extra_new=30)\n            cid = await ensure_current_card(session, user.id, deck_id, sdate, now_utc)\n\n        if not cid:\n            await call.message.answer(no_cards_today(), reply_markup=kb_study_more(deck_id))\n            await call.answer()\n            return\n\n        card = await get_card(session, cid)\n        if not card:\n            await call.message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            await call.answer()\n            return\n\n        await _send_card(bot, call.message.chat.id, card, deck_id)\n        await call.answer()\n\n\n@router.message(F.text)\nasync def on_answer(message: Message, session: AsyncSession, settings, locks: LockRegistry, bot: Bot):\n    # Find any active session for today where current_card_id is not null.\n    user = await get_or_create_user(session, message.from_user.id)\n\n    sdate = today_date(settings.tz)\n    res = await session.execute(\n        select(StudySession)\n        .where(StudySession.user_id == user.id, StudySession.study_date == sdate, StudySession.current_card_id.is_not(None))\n        .order_by(StudySession.updated_at.desc())\n        .limit(1)\n    )\n    sess = res.scalar_one_or_none()\n    if not sess or not sess.current_card_id:\n        await message.answer(need_today_first())\n        return\n\n    deck_id = sess.deck_id\n    lock = locks.lock((user.id, deck_id))\n    async with lock:\n        sess2 = await get_today_session(session, user.id, deck_id, sdate)\n        if not sess2 or not sess2.current_card_id:\n            await message.answer(need_today_first())\n            return\n\n        card_id = sess2.current_card_id\n        card = await get_card(session, card_id)\n        if not card:\n            await record_answered_card(session, sess2, card_id)\n            cid = await ensure_current_card(session, user.id, deck_id, sdate, datetime.utcnow())\n            if cid:\n                next_card = await get_card(session, cid)\n                if next_card:\n                    await _send_card(bot, message.chat.id, next_card, deck_id)\n            else:\n                await message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            return\n\n        now_utc = datetime.utcnow()\n        review = await get_review(session, user.id, card.id)\n        gr = grade(\n            user_text=message.text,\n            correct_text=card.answer_text,\n            alt_answers=card.alt_answers,\n            ok=settings.similarity_ok,\n            almost=settings.similarity_almost,\n        )\n\n        updated = apply_srs(\n            review=review,\n            verdict=gr.verdict,\n            now_utc=now_utc,\n            learning_steps_minutes=settings.learning_steps_minutes,\n            graduate_days=settings.learning_graduate_days,\n            last_answer_raw=message.text,\n            last_score=gr.score,\n        )\n        updated.user_id = user.id\n        updated.card_id = card.id\n        await upsert_review(session, updated)\n\n        uk_text = await get_card_translation_uk(session, card.id)\n        cmp = format_compare(card.answer_text, message.text, gr.score, gr.verdict, uk=uk_text)\n        await message.answer(cmp, parse_mode='HTML', disable_web_page_preview=True)\n\n        await asyncio.sleep(1)\n\n        await record_answered_card(session, sess2, card_id)\n        next_id = await ensure_current_card(session, user.id, deck_id, sdate, datetime.utcnow())\n        if not next_id:\n            await message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            return\n        next_card = await get_card(session, next_id)\n        if not next_card:\n            await message.answer(done_today(), reply_markup=kb_study_more(deck_id))\n            return\n        await _send_card(bot, message.chat.id, next_card, deck_id)\n"
    "path": "app/logging_config.py",
    "content": "import logging\nimport sys\n\ndef setup_logging() -> None:\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s | %(levelname)s | %(name)s | %(message)s\",\n        stream=sys.stdout,\n    )\n"
    "path": "app/main.py",
    "content": "from __future__ import annotations\n\nimport asyncio\nimport logging\n\nfrom aiogram import Bot\nfrom aiogram.dispatcher.middlewares.base import BaseMiddleware\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.config import load_settings\nfrom app.logging_config import setup_logging\nfrom app.bot.factory import create_bot, create_dispatcher\nfrom app.db.engine import init_engine, get_sessionmaker\nfrom app.db.models import Base\n\nfrom app.utils.locks import LockRegistry\n\nimport uvicorn\nfrom app.web.app import create_web_app\nfrom app.services.scheduler import run_daily_7am_push, run_due_learning_push\n\nlogger = logging.getLogger(\"app.main\")\n\nclass DbSessionMiddleware(BaseMiddleware):\n    def __init__(self, sessionmaker):\n        self._sessionmaker = sessionmaker\n\n    async def __call__(self, handler, event, data):\n        async with self._sessionmaker() as session:\n            data[\"session\"] = session\n            return await handler(event, data)\n\nclass SettingsMiddleware(BaseMiddleware):\n    def __init__(self, settings):\n        self._settings = settings\n    async def __call__(self, handler, event, data):\n        data[\"settings\"] = self._settings\n        return await handler(event, data)\n\nclass BotUsernameMiddleware(BaseMiddleware):\n    def __init__(self, bot: Bot):\n        self._bot = bot\n        self._username = None\n\n    async def __call__(self, handler, event, data):\n        if self._username is None:\n            me = await self._bot.get_me()\n            self._username = me.username\n        data[\"bot_username\"] = self._username\n        return await handler(event, data)\n\nclass LocksMiddleware(BaseMiddleware):\n    def __init__(self, locks: LockRegistry):\n        self._locks = locks\n    async def __call__(self, handler, event, data):\n        data[\"locks\"] = self._locks\n        return await handler(event, data)\n\nclass SessionmakerMiddleware(BaseMiddleware):\n    def __init__(self, sessionmaker):\n        self._sessionmaker = sessionmaker\n    async def __call__(self, handler, event, data):\n        data[\"sessionmaker\"] = self._sessionmaker\n        return await handler(event, data)\n\nasync def _init_db(database_url: str):\n    from sqlalchemy.ext.asyncio import create_async_engine\n    engine = create_async_engine(database_url, echo=False, future=True)\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    await engine.dispose()\n\nasync def run_web(settings, bot: Bot, bot_username: str, sessionmaker):\n    app = create_web_app(settings=settings, bot=bot, bot_username=bot_username, sessionmaker=sessionmaker)\n    config = uvicorn.Config(app, host=settings.web_host, port=settings.web_port, log_level=\"info\")\n    server = uvicorn.Server(config)\n    await server.serve()\n\nasync def main():\n    setup_logging()\n    settings = load_settings()\n\n    init_engine(settings.database_url)\n    sessionmaker = get_sessionmaker()\n\n    # create tables\n    await _init_db(settings.database_url)\n\n    bot = create_bot(settings.bot_token)\n    dp = create_dispatcher()\n\n    locks = LockRegistry()\n\n    dp.update.middleware(DbSessionMiddleware(sessionmaker))\n    dp.update.middleware(SettingsMiddleware(settings))\n    dp.update.middleware(BotUsernameMiddleware(bot))\n    dp.update.middleware(LocksMiddleware(locks))\n    dp.update.middleware(SessionmakerMiddleware(sessionmaker))\n\n    me = await bot.get_me()\n    bot_username = me.username\n\n    logger.info(\"Bot started\")\n    logger.info(\"Web server: %s\", f\"{settings.web_base_url} (listening on {settings.web_host}:{settings.web_port})\")\n\n    await asyncio.gather(\n        dp.start_polling(bot),\n        run_web(settings, bot, bot_username, sessionmaker),\n        run_daily_7am_push(bot=bot, settings=settings, sessionmaker=sessionmaker),\n        run_due_learning_push(bot=bot, settings=settings, sessionmaker=sessionmaker),\n    )\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"
    "path": "app/services/admin_auth.py",
    "content": "from __future__ import annotations\n\nimport base64\nimport hmac\nimport hashlib\nimport time\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass(frozen=True)\nclass UploadTokenData:\n    admin_id: int\n    exp: int\n\ndef _b64url_encode(b: bytes) -> str:\n    return base64.urlsafe_b64encode(b).decode(\"ascii\").rstrip(\"=\")\n\ndef _b64url_decode(s: str) -> bytes:\n    pad = \"=\" * ((4 - len(s) % 4) % 4)\n    return base64.urlsafe_b64decode(s + pad)\n\ndef make_upload_token(secret: str, admin_id: int, ttl_seconds: int = 3600) -> str:\n    exp = int(time.time()) + int(ttl_seconds)\n    payload = f\"{admin_id}:{exp}\".encode(\"utf-8\")\n    sig = hmac.new(secret.encode(\"utf-8\"), payload, hashlib.sha256).hexdigest()[:24]\n    raw = payload + b\":\" + sig.encode(\"ascii\")\n    return _b64url_encode(raw)\n\ndef verify_upload_token(secret: str, token: str) -> Optional[UploadTokenData]:\n    try:\n        raw = _b64url_decode(token)\n        parts = raw.decode(\"utf-8\").split(\":\")\n        if len(parts) != 3:\n            return None\n        admin_id = int(parts[0])\n        exp = int(parts[1])\n        sig = parts[2]\n        if exp < int(time.time()):\n            return None\n        payload = f\"{admin_id}:{exp}\".encode(\"utf-8\")\n        expected = hmac.new(secret.encode(\"utf-8\"), payload, hashlib.sha256).hexdigest()[:24]\n        if not hmac.compare_digest(sig, expected):\n            return None\n        return UploadTokenData(admin_id=admin_id, exp=exp)\n    except Exception:\n        return None\n"
    "path": "app/services/apkg_importer/__init__.py",
    "content": ""
    "path": "app/services/apkg_importer/build_cards.py",
    "content": "from __future__ import annotations\n\nimport json, hashlib\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom app.services.apkg_importer.extract_media import find_media_names\nfrom app.services.apkg_importer.extract_text import extract_answer_text\nfrom app.utils.html_strip import strip_html\n\n@dataclass\nclass CardDTO:\n    note_guid: str\n    answer_text: str\n    alt_answers: list[str]\n    filename: str\n    media_bytes: bytes\n    media_sha256: str\n    media_kind: str  # \"video\" or \"audio\"\n\nVIDEO_EXT = {\".mp4\",\".webm\",\".mov\",\".mkv\",\".m4v\"}\nAUDIO_EXT = {\".mp3\",\".m4a\",\".ogg\",\".wav\",\".flac\"}\n\ndef _kind_from_filename(name: str) -> str:\n    n = name.lower()\n    for ext in VIDEO_EXT:\n        if n.endswith(ext):\n            return \"video\"\n    for ext in AUDIO_EXT:\n        if n.endswith(ext):\n            return \"audio\"\n    return \"video\"\n\ndef _sha(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef _load_media_map(media_path: Path) -> dict[str,str]:\n    # media file is JSON mapping index->filename\n    raw = media_path.read_text(encoding=\"utf-8\")\n    return json.loads(raw)\n\ndef _resolve_media_file(base_dir: Path, media_map: dict[str,str], name: str) -> tuple[str, bytes]:\n    # Try direct filename\n    direct = base_dir / name\n    if direct.exists() and direct.is_file():\n        return name, direct.read_bytes()\n\n    # Sometimes media files are stored by numeric keys (0,1,2) with mapping to names\n    # Find index that matches this filename\n    idx = None\n    for k, v in media_map.items():\n        if v == name:\n            idx = k\n            break\n    if idx is not None:\n        p = base_dir / idx\n        if p.exists() and p.is_file():\n            return name, p.read_bytes()\n\n    # If name itself is numeric\n    p2 = base_dir / name\n    if p2.exists() and p2.is_file():\n        # try map it back to a filename for extension\n        mapped_name = media_map.get(name, name)\n        return mapped_name, p2.read_bytes()\n\n    raise FileNotFoundError(f\"Media not found for: {name}\")\n\ndef build_cards_from_notes(\n    base_dir: Path,\n    notes: list[tuple[str,str]],\n) -> list[CardDTO]:\n    collection = base_dir / \"collection.anki2\"\n    media_file = base_dir / \"media\"\n    if not collection.exists():\n        raise FileNotFoundError(\"collection.anki2 not found in apkg\")\n    if not media_file.exists():\n        raise FileNotFoundError(\"media mapping file not found in apkg\")\n\n    media_map = _load_media_map(media_file)\n\n    dtos: list[CardDTO] = []\n    for guid, flds in notes:\n        fields = flds.split(\"\\x1f\")\n        # Find first field containing media reference\n        media_field_idx = None\n        media_names: list[str] = []\n        for i, field in enumerate(fields):\n            mn = find_media_names(field)\n            if mn:\n                media_field_idx = i\n                media_names = mn\n                break\n        if not media_names:\n            # skip notes without media\n            continue\n\n        # Pick first media reference only (one snippet per card)\n        media_name = media_names[0]\n\n        # Choose back field: prefer second field if exists and not the media field\n        back_candidates = []\n        if len(fields) >= 2:\n            back_candidates.append(fields[1])\n        # Add all fields except media field\n        for i, field in enumerate(fields):\n            if i != media_field_idx:\n                back_candidates.append(field)\n\n        answer_text = \"\"\n        alt_answers: list[str] = []\n        for cand in back_candidates:\n            a, alts = extract_answer_text(cand)\n            if a:\n                answer_text, alt_answers = a, alts\n                break\n\n        if not answer_text:\n            # invalid for our bot\n            continue\n\n        try:\n            resolved_name, media_bytes = _resolve_media_file(base_dir, media_map, media_name)\n        except FileNotFoundError:\n            continue\n\n        sha = _sha(media_bytes)\n        kind = _kind_from_filename(resolved_name)\n\n        dtos.append(CardDTO(\n            note_guid=guid,\n            answer_text=answer_text,\n            alt_answers=alt_answers,\n            filename=resolved_name,\n            media_bytes=media_bytes,\n            media_sha256=sha,\n            media_kind=kind,\n        ))\n\n    return dtos\n"
    "path": "app/services/apkg_importer/extract_media.py",
    "content": "from __future__ import annotations\nimport re\n\nSOUND_RE = re.compile(r\"\\[sound:([^\\]]+)\\]\", re.IGNORECASE)\nVIDEO_SRC_RE = re.compile(r'(?i)(?:src|data-src)\\s*=\\s*[\"\\']([^\"\\']+)[\"\\']')\n\ndef find_media_names(text: str) -> list[str]:\n    if not text:\n        return []\n    names = []\n    for m in SOUND_RE.finditer(text):\n        names.append(m.group(1).strip())\n    # also HTML video/audio tags\n    for m in VIDEO_SRC_RE.finditer(text):\n        names.append(m.group(1).strip())\n    # de-dup preserve order\n    out = []\n    seen = set()\n    for n in names:\n        if n and n not in seen:\n            seen.add(n)\n            out.append(n)\n    return out\n"
    "path": "app/services/apkg_importer/extract_text.py",
    "content": "from __future__ import annotations\nimport re\nfrom app.utils.html_strip import strip_html\n\nSOUND_TAG_RE = re.compile(r\"\\[sound:[^\\]]+\\]\", re.IGNORECASE)\n\ndef extract_answer_text(back_field: str) -> tuple[str, list[str]]:\n    txt = strip_html(back_field or \"\")\n    # Remove Anki sound tags if present in the back field.\n    txt = SOUND_TAG_RE.sub(\"\", txt).strip()\n\n    if \"||\" in txt:\n        parts = [p.strip() for p in txt.split(\"||\") if p.strip()]\n        if not parts:\n            return \"\", []\n        return parts[0], parts[1:]\n    return txt.strip(), []\n"
    "path": "app/services/apkg_importer/parse_collection.py",
    "content": "from __future__ import annotations\nimport sqlite3\nfrom pathlib import Path\n\ndef iter_notes(collection_path: Path):\n    conn = sqlite3.connect(str(collection_path))\n    try:\n        cur = conn.cursor()\n        cur.execute(\"SELECT guid, flds FROM notes\")\n        for guid, flds in cur.fetchall():\n            yield str(guid), str(flds)\n    finally:\n        conn.close()\n"
    "path": "app/services/apkg_importer/unpack.py",
    "content": "from __future__ import annotations\nimport os, zipfile, shutil\nfrom pathlib import Path\n\ndef unpack_apkg(apkg_path: str, tmp_dir: str, job_id: str) -> Path:\n    base = Path(tmp_dir) / job_id\n    if base.exists():\n        shutil.rmtree(base)\n    base.mkdir(parents=True, exist_ok=True)\n    with zipfile.ZipFile(apkg_path, \"r\") as z:\n        z.extractall(base)\n    return base\n"
  },
  {
    "path": "app/services/card_sender.py",
    "content": "from __future__ import annotations\n\nfrom aiogram import Bot\nfrom aiogram.types import InlineKeyboardMarkup\nfrom app.bot.keyboards import kb_bad_card\n\nasync def send_card_to_chat(bot: Bot, chat_id: int, card, deck_id: str) -> None:\n    # card has: media_kind, tg_file_id, id\n    rm: InlineKeyboardMarkup = kb_bad_card(deck_id, card.id)\n    if card.media_kind == \"audio\":\n        await bot.send_audio(chat_id, card.tg_file_id, reply_markup=rm)\n    else:\n        await bot.send_video(chat_id, card.tg_file_id, reply_markup=rm)\n"
    "content": "from __future__ import annotations\n\nimport html\n\nfrom app.services.grader import Verdict\nfrom app.utils.diff_highlight import highlight_diff\n\n\ndef format_compare(\n    correct: str,\n    user: str,\n    score: int,\n    verdict: Verdict,\n    uk: str | None = None,\n    max_len: int = 3500,\n) -> str:\n    icon = \"\u2705\" if verdict == Verdict.OK else (\"\ud83d\udfe8\" if verdict == Verdict.ALMOST else \"\u274c\")\n\n    if correct:\n        corr_html, user_html = highlight_diff(correct, user or \"\")\n        if not corr_html:\n            corr_html = html.escape(correct, quote=False)\n        if not user_html:\n            user_html = html.escape(user or \"\", quote=False)\n    else:\n        corr_html = html.escape(correct or \"\", quote=False)\n        user_html = html.escape(user or \"\", quote=False)\n\n    lines = [f\"{icon} {score}/100\", f\"Correct: {corr_html}\"]\n    if uk:\n        uk_html = html.escape(uk, quote=False)\n        lines.append(f\"UA: {uk_html}\")\n    lines.append(f\"You: {user_html}\")\n\n    msg = \"\\n\".join(lines)\n    if len(msg) > max_len:\n        msg = msg[: max_len - 3] + \"...\"\n    return msg\n"
    "path": "app/services/flag_service.py",
    "content": "from __future__ import annotations\nfrom datetime import datetime\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import update\n\nfrom app.db.models import Review, ReviewState\nfrom app.db.repo import add_flag, get_review\n\nasync def flag_bad_card(session: AsyncSession, user_id: str, card_id: str) -> None:\n    await add_flag(session, user_id, card_id, reason=\"bad_card\")\n    review = await get_review(session, user_id, card_id)\n    if review is None:\n        review = Review(user_id=user_id, card_id=card_id, state=ReviewState.suspended.value, updated_at=datetime.utcnow())\n        session.add(review)\n        await session.commit()\n        return\n    review.state = ReviewState.suspended.value\n    review.updated_at = datetime.utcnow()\n    session.add(review)\n    await session.commit()\n"
    "path": "app/services/grader.py",
    "content": "from __future__ import annotations\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nfrom app.utils.text_norm import normalize_answer\nfrom app.utils.similarity import similarity_score\n\nclass Verdict(str, Enum):\n    OK = \"OK\"\n    ALMOST = \"ALMOST\"\n    BAD = \"BAD\"\n\n@dataclass(frozen=True)\nclass GradeResult:\n    score: int\n    verdict: Verdict\n    best_match: str\n\ndef grade(user_text: str, correct_text: str, alt_answers: list[str], ok: int, almost: int) -> GradeResult:\n    u = normalize_answer(user_text or \"\")\n    candidates = [correct_text] + (alt_answers or [])\n    best_score = -1\n    best_match = correct_text\n    for c in candidates:\n        cn = normalize_answer(c or \"\")\n        sc = similarity_score(u, cn)\n        if sc > best_score:\n            best_score = sc\n            best_match = c\n    if best_score >= ok:\n        v = Verdict.OK\n    elif best_score >= almost:\n        v = Verdict.ALMOST\n    else:\n        v = Verdict.BAD\n    return GradeResult(score=int(best_score), verdict=v, best_match=best_match)\n"
    "path": "app/services/import_service.py",
    "content": "from __future__ import annotations\n\nimport asyncio\nimport os\nimport uuid\nfrom pathlib import Path\n\nfrom aiogram import Bot\nfrom sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession\n\nfrom app.db.models import Card\nfrom app.db.repo import create_deck\nfrom app.services.media_store import get_or_upload_file_id\nfrom app.services.apkg_importer.unpack import unpack_apkg\nfrom app.services.apkg_importer.parse_collection import iter_notes\nfrom app.services.apkg_importer.build_cards import build_cards_from_notes\nfrom app.services.translate_service import (\n    TranslateConfig,\n    get_or_create_translation_cache,\n    link_card_translation,\n)\nfrom app.bot.messages import deck_link\n\n\nasync def import_apkg_from_path(\n    *,\n    settings,\n    bot: Bot,\n    bot_username: str,\n    sessionmaker: async_sessionmaker[AsyncSession],\n    admin_tg_id: int,\n    apkg_path: str,\n    deck_title: str,\n    new_per_day: int,\n) -> dict:\n    \"\"\"Imports an .apkg, uploads media to Telegram, creates deck+cards.\n\n    Additionally (if enabled via env), translates card subtitles to Ukrainian\n    and stores them for displaying alongside 'Correct' after answering.\n    \"\"\"\n\n    os.makedirs(settings.import_tmp_dir, exist_ok=True)\n    job_id = uuid.uuid4().hex\n\n    # Parse apkg in thread to avoid blocking event loop\n    base_dir = await asyncio.to_thread(unpack_apkg, apkg_path, settings.import_tmp_dir, job_id)\n    collection_path = Path(base_dir) / \"collection.anki2\"\n    notes = await asyncio.to_thread(lambda: list(iter_notes(collection_path)))\n    dtos = await asyncio.to_thread(build_cards_from_notes, Path(base_dir), notes)\n\n    cfg = TranslateConfig(\n        enabled=getattr(settings, \"subtitle_translate_enabled\", True),\n        source_lang=getattr(settings, \"subtitle_translate_source_lang\", \"auto\"),\n        target_lang=getattr(settings, \"subtitle_translate_target_lang\", \"uk\"),\n        concurrency=getattr(settings, \"translate_concurrency\", 1),\n        min_delay_ms=getattr(settings, \"translate_min_delay_ms\", 250),\n        max_retries=getattr(settings, \"translate_max_retries\", 30),\n        base_delay_ms=getattr(settings, \"translate_base_delay_ms\", 750),\n        max_delay_ms=getattr(settings, \"translate_max_delay_ms\", 60000),\n    )\n    translate_sem = asyncio.Semaphore(max(1, int(cfg.concurrency or 1)))\n\n    imported = 0\n    skipped = 0\n\n    async with sessionmaker() as session:\n        deck = await create_deck(session, admin_tg_id, deck_title, new_per_day=new_per_day)\n\n        # Insert cards. Commit in chunks.\n        for dto in dtos:\n            try:\n                file_id = await get_or_upload_file_id(\n                    db=session,\n                    bot=bot,\n                    admin_tg_id=admin_tg_id,\n                    media_bytes=dto.media_bytes,\n                    filename=dto.filename,\n                    media_sha256=dto.media_sha256,\n                    media_kind=dto.media_kind,\n                )\n\n                card_id = str(uuid.uuid4())\n                card = Card(\n                    id=card_id,\n                    deck_id=deck.id,\n                    note_guid=dto.note_guid,\n                    answer_text=dto.answer_text,\n                    alt_answers=dto.alt_answers,\n                    media_kind=dto.media_kind,\n                    tg_file_id=file_id,\n                    media_sha256=dto.media_sha256,\n                    is_valid=True,\n                )\n                session.add(card)\n\n                # Translation should not break import.\n                try:\n                    cache_key = await get_or_create_translation_cache(\n                        session,\n                        source_lang=cfg.source_lang,\n                        target_lang=cfg.target_lang,\n                        text=dto.answer_text,\n                        cfg=cfg,\n                        sem=translate_sem,\n                    )\n                    if cache_key:\n                        await link_card_translation(session, card_id=card_id, cache_key=cache_key)\n                except Exception:\n                    # ignore translation failures, keep the card\n                    pass\n\n                imported += 1\n                if imported % 50 == 0:\n                    await session.commit()\n            except Exception:\n                await session.rollback()\n                skipped += 1\n                continue\n\n        await session.commit()\n        link = deck_link(bot_username, deck.token)\n\n    # cleanup unpack dir\n    try:\n        import shutil\n\n        shutil.rmtree(base_dir, ignore_errors=True)\n    except Exception:\n        pass\n\n    return {\"imported\": imported, \"skipped\": skipped, \"link\": link}\n"
    "path": "app/services/media_store.py",
    "content": "from __future__ import annotations\n\nimport hashlib\nfrom dataclasses import dataclass\nfrom aiogram import Bot\nfrom aiogram.types import BufferedInputFile\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom app.db.repo import find_file_id_by_sha\n\nVIDEO_EXT = {\".mp4\",\".webm\",\".mov\",\".mkv\",\".m4v\"}\nAUDIO_EXT = {\".mp3\",\".m4a\",\".ogg\",\".wav\",\".flac\"}\n\ndef sha256_bytes(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef guess_kind(filename: str) -> str:\n    fn = filename.lower()\n    for ext in VIDEO_EXT:\n        if fn.endswith(ext):\n            return \"video\"\n    for ext in AUDIO_EXT:\n        if fn.endswith(ext):\n            return \"audio\"\n    # default video\n    return \"video\"\n\nasync def get_or_upload_file_id(\n    *,\n    db: AsyncSession,\n    bot: Bot,\n    admin_tg_id: int,\n    media_bytes: bytes,\n    filename: str,\n    media_sha256: str,\n    media_kind: str,\n) -> str:\n    existing = await find_file_id_by_sha(db, media_sha256)\n    if existing:\n        return existing\n\n    inp = BufferedInputFile(media_bytes, filename=filename)\n    if media_kind == \"audio\":\n        msg = await bot.send_audio(chat_id=admin_tg_id, audio=inp)\n        if not msg.audio:\n            raise RuntimeError(\"Telegram did not return audio object\")\n        return msg.audio.file_id\n    else:\n        msg = await bot.send_video(chat_id=admin_tg_id, video=inp, supports_streaming=True)\n        if not msg.video:\n            raise RuntimeError(\"Telegram did not return video object\")\n        return msg.video.file_id\n"
    "path": "app/services/scheduler.py",
    "content": "from __future__ import annotations\n\nimport asyncio\nfrom datetime import datetime, time, timedelta\nfrom zoneinfo import ZoneInfo\n\nfrom sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession\nfrom sqlalchemy import select, func\n\nfrom aiogram import Bot\n\nfrom app.utils.timez import today_date\nfrom app.db.models import Enrollment, User, Deck, StudySession\nfrom app.services.study_engine import ensure_current_card, start_or_resume_today\nfrom app.db.repo import (\n    claim_current_if_none,\n    get_card,\n    get_due_learning_cards,\n    update_session_progress,\n    get_today_session,\n)\nfrom app.services.card_sender import send_card_to_chat\n\n\nasync def _sleep_until_next_7am(tz_name: str) -> None:\n    tz = ZoneInfo(tz_name)\n    now = datetime.now(tz)\n    target = datetime.combine(now.date(), time(7, 0), tzinfo=tz)\n    if now >= target:\n        target = target + timedelta(days=1)\n    delta = (target - now).total_seconds()\n    if delta < 1:\n        delta = 1\n    await asyncio.sleep(delta)\n\n\nasync def run_daily_7am_push(\n    *,\n    bot: Bot,\n    settings,\n    sessionmaker: async_sessionmaker[AsyncSession],\n):\n    # On startup: if local time already past 07:00, do a one-time catch-up (create missing sessions for today).\n    tz = ZoneInfo(settings.tz)\n    now_local = datetime.now(tz)\n    if now_local.time() >= time(7, 0):\n        await push_today_cards(bot=bot, settings=settings, sessionmaker=sessionmaker)\n\n    # Runs forever: at 07:00 in settings.tz, create today's sessions (if missing) and send first card.\n    while True:\n        await _sleep_until_next_7am(settings.tz)\n        await push_today_cards(bot=bot, settings=settings, sessionmaker=sessionmaker)\n\n\nasync def push_today_cards(*, bot: Bot, settings, sessionmaker: async_sessionmaker[AsyncSession]) -> None:\n    now_utc = datetime.utcnow()\n    sdate = today_date(settings.tz)\n\n    async with sessionmaker() as session:\n        # Active enrollments only\n        stmt = (\n            select(User.tg_id, User.id, Deck.id)\n            .select_from(Enrollment)\n            .join(User, User.id == Enrollment.user_id)\n            .join(Deck, Deck.id == Enrollment.deck_id)\n            .where(Deck.is_active == True)\n        )\n        rows = (await session.execute(stmt)).all()\n\n    # Process each enrollment; create its own session scope to keep transactions small\n    for tg_id, user_id, deck_id in rows:\n        try:\n            async with sessionmaker() as s:\n                sess, _created = await start_or_resume_today(s, user_id, deck_id, sdate, now_utc)\n                cid = await ensure_current_card(s, user_id, deck_id, sdate, now_utc)\n                if not getattr(sess, \"queue\", None) or not cid:\n                    continue\n\n                card = await get_card(s, cid)\n                if not card:\n                    continue\n                await send_card_to_chat(bot, tg_id, card, deck_id)\n\n            # basic rate limit\n            await asyncio.sleep(0.05)\n        except Exception:\n            # user blocked bot / network error / etc -> ignore\n            continue\n\n\nasync def run_due_learning_push(\n    *,\n    bot: Bot,\n    settings,\n    sessionmaker: async_sessionmaker[AsyncSession],\n    interval_seconds: int = 45,\n    send_card_fn=send_card_to_chat,\n):\n    while True:\n        try:\n            await _run_due_learning_push_once(bot=bot, settings=settings, sessionmaker=sessionmaker, send_card_fn=send_card_fn)\n        except Exception:\n            # swallow errors to keep loop alive\n            pass\n        await asyncio.sleep(interval_seconds)\n\n\nasync def _run_due_learning_push_once(\n    *,\n    bot: Bot,\n    settings,\n    sessionmaker: async_sessionmaker[AsyncSession],\n    send_card_fn=send_card_to_chat,\n):\n    now_utc = datetime.utcnow()\n    sdate = today_date(settings.tz)\n\n    async with sessionmaker() as session:\n        stmt = (\n            select(StudySession)\n            .where(\n                StudySession.study_date == sdate,\n                StudySession.current_card_id.is_(None),\n                StudySession.pos >= func.json_array_length(StudySession.queue),\n            )\n        )\n        sessions = (await session.execute(stmt)).scalars().all()\n\n    for sess in sessions:\n        async with sessionmaker() as s:\n            # Re-fetch to ensure we have fresh state inside transaction\n            current = await get_today_session(s, sess.user_id, sess.deck_id, sdate)\n            if not current or current.current_card_id is not None:\n                continue\n            queue = current.queue or []\n            if current.pos < len(queue):\n                continue\n\n            due_learning = await get_due_learning_cards(s, current.user_id, current.deck_id, now_utc, limit=1)\n            if not due_learning:\n                continue\n            cid = due_learning[0]\n            claimed = await claim_current_if_none(s, current.id, cid)\n            if not claimed:\n                continue\n\n            card = await get_card(s, cid)\n            if not card:\n                await update_session_progress(s, current.id, current.pos, None)\n                continue\n\n            tg_id = (await s.execute(select(User.tg_id).where(User.id == current.user_id))).scalar_one()\n            await send_card_fn(bot, tg_id, card, current.deck_id)\n"
    "path": "app/services/srs.py",
    "content": "from __future__ import annotations\n\nfrom datetime import datetime, timedelta\nfrom app.db.models import Review, ReviewState\nfrom app.services.grader import Verdict\n\ndef _utcnow() -> datetime:\n    return datetime.utcnow()\n\ndef apply_srs(\n    review: Review | None,\n    verdict: Verdict,\n    now_utc: datetime,\n    learning_steps_minutes: list[int],\n    graduate_days: int,\n    last_answer_raw: str,\n    last_score: int,\n) -> Review:\n    if review is None:\n        # first encounter -> learning step 0\n        r = Review(\n            state=ReviewState.learning.value,\n            step_index=0,\n            ease=2.5,\n            interval_days=0,\n            lapses=0,\n            due_at=now_utc + timedelta(minutes=learning_steps_minutes[0]),\n            last_answer_raw=last_answer_raw,\n            last_score=last_score,\n            updated_at=now_utc,\n        )\n        return r\n\n    review.last_answer_raw = last_answer_raw\n    review.last_score = last_score\n    review.updated_at = now_utc\n\n    # suspended stays suspended\n    if review.state == ReviewState.suspended.value:\n        return review\n\n    if review.state in (ReviewState.new.value,):\n        review.state = ReviewState.learning.value\n        review.step_index = 0\n        review.due_at = now_utc + timedelta(minutes=learning_steps_minutes[0])\n\n    if review.state == ReviewState.learning.value:\n        if verdict == Verdict.BAD:\n            review.step_index = 0\n            review.due_at = now_utc + timedelta(minutes=learning_steps_minutes[0])\n            return review\n\n        if verdict == Verdict.ALMOST:\n            # do not advance; schedule next step time (or same step+1)\n            idx = min(review.step_index + 1, len(learning_steps_minutes) - 1)\n            review.due_at = now_utc + timedelta(minutes=learning_steps_minutes[idx])\n            return review\n\n        # OK\n        review.step_index += 1\n        if review.step_index >= len(learning_steps_minutes):\n            review.state = ReviewState.review.value\n            review.interval_days = graduate_days\n            review.due_at = now_utc + timedelta(days=graduate_days)\n        else:\n            review.due_at = now_utc + timedelta(minutes=learning_steps_minutes[review.step_index])\n        return review\n\n    # review state\n    if review.state == ReviewState.review.value:\n        if verdict == Verdict.BAD:\n            review.lapses += 1\n            review.ease = max(1.3, review.ease - 0.2)\n            review.interval_days = 1\n            review.due_at = now_utc + timedelta(days=1)\n            return review\n\n        if verdict == Verdict.ALMOST:\n            review.ease = max(1.3, review.ease - 0.15)\n            review.interval_days = max(1, int(round(review.interval_days * 1.2))) or 1\n            review.due_at = now_utc + timedelta(days=review.interval_days)\n            return review\n\n        # OK\n        review.interval_days = max(1, int(round(review.interval_days * review.ease))) or 1\n        review.due_at = now_utc + timedelta(days=review.interval_days)\n        return review\n\n    # fallback\n    return review\n"
    "path": "app/services/stats_service.py",
    "content": "from __future__ import annotations\nfrom datetime import datetime, timedelta, date\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func\nfrom app.db.models import Enrollment, Review, Deck, Flag, Card, StudySession\n\nasync def student_stats(session: AsyncSession, user_id: str, deck_id: str, study_date: date) -> str:\n    # count answers today by checking reviews updated_at within today range (UTC approximation)\n    # Minimal: show session progress.\n    res = await session.execute(\n        select(StudySession).where(StudySession.user_id==user_id, StudySession.deck_id==deck_id, StudySession.study_date==study_date)\n    )\n    ss = res.scalar_one_or_none()\n    if not ss:\n        return \"No session today.\"\n    total = len(ss.queue or [])\n    done = min(ss.pos, total)\n    return f\"Today: {done}/{total} cards.\"\n\nasync def admin_stats(session: AsyncSession, deck_id: str) -> str:\n    # enrolled\n    enrolled = await session.execute(select(func.count(Enrollment.id)).where(Enrollment.deck_id==deck_id))\n    enrolled_n = int(enrolled.scalar() or 0)\n    # flagged\n    flagged = await session.execute(\n        select(func.count(Flag.id))\n        .join(Card, Card.id==Flag.card_id)\n        .where(Card.deck_id==deck_id)\n    )\n    flagged_n = int(flagged.scalar() or 0)\n    return f\"Enrolled: {enrolled_n}\\nFlags: {flagged_n}\"\n"
    "path": "app/services/student_progress.py",
    "content": "from __future__ import annotations\n\nfrom datetime import date, timedelta, datetime\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.db.repo import (\n    compute_overall_progress,\n    get_study_sessions_for_user_deck_in_range,\n    get_today_session,\n)\n\n\ndef _session_progress(session_obj) -> tuple[int, int]:\n    if not session_obj:\n        return 0, 0\n    total = len(session_obj.queue or [])\n    done = min(session_obj.pos, total)\n    return done, total\n\n\nasync def get_today_progress(session: AsyncSession, user_id: str, deck_id: str, study_date: date) -> tuple[int, int]:\n    today_session = await get_today_session(session, user_id, deck_id, study_date)\n    return _session_progress(today_session)\n\n\nasync def get_daily_progress_history(\n    session: AsyncSession, user_id: str, deck_id: str, end_date: date, days: int = 7\n) -> list[tuple[date, int, int]]:\n    start_date = end_date - timedelta(days=days - 1)\n    sessions = await get_study_sessions_for_user_deck_in_range(session, user_id, deck_id, start_date, end_date)\n    by_date = {s.study_date: _session_progress(s) for s in sessions}\n    history: list[tuple[date, int, int]] = []\n    for i in range(days):\n        day = start_date + timedelta(days=i)\n        done, total = by_date.get(day, (0, 0))\n        history.append((day, done, total))\n    return history\n\n\nasync def get_overall_progress_summary(\n    session: AsyncSession, user_id: str, deck_id: str, now: datetime | None = None\n) -> dict:\n    return await compute_overall_progress(session, user_id, deck_id, now=now)\n"
    "path": "app/services/study_engine.py",
    "content": "from __future__ import annotations\n\nfrom datetime import datetime\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.db.repo import (\n    claim_current_if_none,\n    create_today_session,\n    get_deck_by_id,\n    get_due_learning_cards,\n    get_due_review_cards,\n    get_new_cards,\n    get_today_session,\n    update_session_progress,\n    update_session_queue,\n)\nfrom app.services.study_planner import build_today_queue\n\n\nasync def start_or_resume_today(\n    session: AsyncSession,\n    user_id: str,\n    deck_id: str,\n    study_date,\n    now_utc: datetime,\n) -> tuple[object, bool]:\n    existing = await get_today_session(session, user_id, deck_id, study_date)\n    if existing:\n        return existing, False\n    queue = await build_today_queue(session, user_id, deck_id, now_utc)\n    created = await create_today_session(session, user_id, deck_id, study_date, queue)\n    return created, True\n\n\nasync def ensure_current_card(\n    session: AsyncSession,\n    user_id: str,\n    deck_id: str,\n    study_date,\n    now_utc: datetime,\n) -> str | None:\n    sess = await get_today_session(session, user_id, deck_id, study_date)\n    if not sess:\n        queue = await build_today_queue(session, user_id, deck_id, now_utc)\n        sess, _ = await start_or_resume_today(session, user_id, deck_id, study_date, now_utc)\n        # persist the freshly built queue in case start_or_resume_today reused a stale queue\n        await update_session_queue(session, sess.id, queue, None)\n        sess = await get_today_session(session, user_id, deck_id, study_date)\n\n    if getattr(sess, \"current_card_id\", None):\n        return sess.current_card_id\n\n    pos = getattr(sess, \"pos\", 0) or 0\n    queue = getattr(sess, \"queue\", []) or []\n\n    learning_due = await get_due_learning_cards(session, user_id, deck_id, now_utc, limit=1)\n    if learning_due:\n        cid = learning_due[0]\n        claimed = await claim_current_if_none(session, sess.id, cid)\n        if claimed:\n            return cid\n        sess = await get_today_session(session, user_id, deck_id, study_date)\n        return getattr(sess, \"current_card_id\", None)\n\n    if pos < len(queue):\n        cid = queue[pos]\n        claimed = await claim_current_if_none(session, sess.id, cid)\n        if claimed:\n            return cid\n        sess = await get_today_session(session, user_id, deck_id, study_date)\n        return getattr(sess, \"current_card_id\", None)\n\n    return None\n\n\nasync def record_answered_card(\n    session: AsyncSession,\n    study_session,\n    answered_card_id: str,\n) -> tuple[int, bool]:\n    \"\"\"Update session after a card was answered.\n\n    Returns (new_pos, was_main_queue_card).\n    \"\"\"\n\n    was_main_queue = False\n    pos = getattr(study_session, \"pos\", 0) or 0\n    queue = getattr(study_session, \"queue\", []) or []\n    if pos < len(queue) and queue[pos] == answered_card_id:\n        was_main_queue = True\n        pos += 1\n\n    await update_session_progress(session, study_session.id, pos, None)\n    return pos, was_main_queue\n\n\nasync def extend_today_with_more(\n    session: AsyncSession,\n    user_id: str,\n    deck_id: str,\n    study_date,\n    now_utc: datetime,\n    extra_new: int = 30,\n) -> object | None:\n    sess = await get_today_session(session, user_id, deck_id, study_date)\n    if not sess:\n        created, _ = await start_or_resume_today(session, user_id, deck_id, study_date, now_utc)\n        return created\n\n    if getattr(sess, \"current_card_id\", None):\n        return sess\n\n    deck = await get_deck_by_id(session, deck_id)\n    if not deck:\n        return None\n\n    due_review = await get_due_review_cards(session, user_id, deck_id, now_utc, limit=50)\n    new = await get_new_cards(session, deck_id, user_id, deck.new_per_day + extra_new)\n\n    seen = set(sess.queue or [])\n    add: list[str] = []\n    for cid in due_review + new:\n        if cid not in seen:\n            seen.add(cid)\n            add.append(cid)\n\n    if not add:\n        return sess\n\n    new_queue = (sess.queue or []) + add\n    await update_session_queue(session, sess.id, new_queue, None)\n    return await get_today_session(session, user_id, deck_id, study_date)\n"
    "path": "app/services/study_planner.py",
    "content": "from __future__ import annotations\nfrom datetime import datetime\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.db.repo import get_new_cards, get_due_review_cards\nfrom app.db.repo import get_deck_by_id\n\n\ndef _dedupe_preserve_order(ids: list[str]) -> list[str]:\n    seen: set[str] = set()\n    out: list[str] = []\n    for cid in ids:\n        if cid in seen:\n            continue\n        seen.add(cid)\n        out.append(cid)\n    return out\n\n\nasync def build_today_queue(session: AsyncSession, user_id: str, deck_id: str, now_utc: datetime) -> list[str]:\n    deck = await get_deck_by_id(session, deck_id)\n    if deck is None:\n        return []\n    due_review = await get_due_review_cards(session, user_id, deck_id, now_utc, limit=50)\n    new = await get_new_cards(session, deck_id, user_id, deck.new_per_day)\n    queue = _dedupe_preserve_order(due_review + new)\n    return queue\n"
    "path": "app/services/token_service.py",
    "content": "from __future__ import annotations\nimport secrets\n\ndef generate_deck_token() -> str:\n    return secrets.token_urlsafe(18)\n\ndef build_payload(deck_token: str) -> str:\n    return f\"deck_{deck_token}\"\n\ndef parse_payload(payload: str | None) -> str | None:\n    if not payload:\n        return None\n    if payload.startswith(\"deck_\"):\n        return payload[len(\"deck_\"):]\n    return None\n"
    "path": "app/services/translate_google_free.py",
    "content": "from __future__ import annotations\n\nimport asyncio\nimport random\nfrom dataclasses import dataclass\nfrom typing import Any\nfrom urllib.parse import quote\n\nimport aiohttp\n\n\n@dataclass(frozen=True)\nclass TranslationSettings:\n    enabled: bool\n    source_lang: str\n    target_lang: str\n    min_delay_s: float = 0.15\n    timeout_s: float = 20.0\n    max_retries: int = 60\n    backoff_base_s: float = 1.0\n    backoff_max_s: float = 60.0\n\n\nclass GoogleFreeTranslator:\n    \"\"\"Unofficial Google Translate endpoint (no API key).\n\n    Uses https://translate.googleapis.com/translate_a/single.\n\n    Note: This endpoint is undocumented; it may be rate-limited or change.\n    The implementation is deliberately conservative: low concurrency, delays,\n    and exponential backoff on 429/5xx.\n    \"\"\"\n\n    def __init__(self, http: aiohttp.ClientSession, settings: TranslationSettings):\n        self._http = http\n        self._s = settings\n        self._cache: dict[str, str] = {}\n        self._last_request_at: float | None = None\n\n    async def translate(self, text: str) -> str | None:\n        if not self._s.enabled:\n            return None\n\n        t = (text or \"\").strip()\n        if not t:\n            return \"\"\n\n        cached = self._cache.get(t)\n        if cached is not None:\n            return cached\n\n        # Keep URLs at safe lengths; split overly long text.\n        if len(t) > 1500:\n            parts = _split_text(t, 1200)\n            out_parts: list[str] = []\n            for part in parts:\n                tr = await self._translate_once_with_retries(part)\n                out_parts.append(tr)\n            out = \"\".join(out_parts).strip()\n            self._cache[t] = out\n            return out\n\n        out = await self._translate_once_with_retries(t)\n        self._cache[t] = out\n        return out\n\n    async def _translate_once_with_retries(self, text: str) -> str:\n        # polite pacing\n        await self._sleep_if_needed()\n\n        encoded = quote(text, safe=\"\")\n        url = (\n            \"https://translate.googleapis.com/translate_a/single\"\n            f\"?client=gtx&sl={self._s.source_lang}&tl={self._s.target_lang}&dt=t&q={encoded}\"\n        )\n\n        attempt = 0\n        while True:\n            attempt += 1\n            try:\n                timeout = aiohttp.ClientTimeout(total=self._s.timeout_s)\n                async with self._http.get(url, timeout=timeout) as resp:\n                    if resp.status in (429, 503, 502, 504):\n                        await self._backoff_sleep(attempt, resp.status)\n                        if attempt < self._s.max_retries:\n                            continue\n                    resp.raise_for_status()\n                    data: Any = await resp.json(content_type=None)\n                    translated = _parse_google_translate_response(data)\n                    return translated\n\n            except (aiohttp.ClientError, asyncio.TimeoutError) as e:\n                # Network issues: retry with backoff.\n                await self._backoff_sleep(attempt, str(e))\n                if attempt >= self._s.max_retries:\n                    # Give up (return original text so UI doesn't break).\n                    return \"\"\n\n    async def _sleep_if_needed(self) -> None:\n        if self._s.min_delay_s <= 0:\n            return\n        loop = asyncio.get_running_loop()\n        now = loop.time()\n        if self._last_request_at is None:\n            self._last_request_at = now\n            return\n        delta = now - self._last_request_at\n        if delta < self._s.min_delay_s:\n            await asyncio.sleep(self._s.min_delay_s - delta)\n        self._last_request_at = loop.time()\n\n    async def _backoff_sleep(self, attempt: int, reason: Any) -> None:\n        # exponential backoff with jitter\n        base = self._s.backoff_base_s\n        delay = min(self._s.backoff_max_s, base * (2 ** min(attempt, 10)))\n        jitter = random.uniform(0, delay * 0.2)\n        await asyncio.sleep(delay + jitter)\n\n\ndef _parse_google_translate_response(data: Any) -> str:\n    # Typical structure: [[['\u041f\u0440\u0438\u0432\u0456\u0442', 'Hello', ...], ...], None, 'en', ...]\n    try:\n        segments = data[0]\n        out = \"\".join((seg[0] or \"\") for seg in segments if seg and isinstance(seg, list))\n        return (out or \"\").strip()\n    except Exception:\n        return \"\"\n\n\ndef _split_text(text: str, max_len: int) -> list[str]:\n    # naive splitting by sentence-ish boundaries; falls back to hard splitting\n    if len(text) <= max_len:\n        return [text]\n\n    seps = [\". \", \"! \", \"? \", \"\\n\", \", \"]\n    parts: list[str] = []\n    buf = \"\"\n\n    def flush():\n        nonlocal buf\n        if buf:\n            parts.append(buf)\n            buf = \"\"\n\n    tokens = [text]\n    for sep in seps:\n        if len(tokens) == 1:\n            tokens = tokens[0].split(sep)\n            if len(tokens) > 1:\n                # re-add separator except for last\n                tokens = [t + (sep if i < len(tokens) - 1 else \"\") for i, t in enumerate(tokens)]\n\n    for tok in tokens:\n        if len(buf) + len(tok) <= max_len:\n            buf += tok\n        else:\n            flush()\n            if len(tok) <= max_len:\n                buf = tok\n            else:\n                # hard split\n                for i in range(0, len(tok), max_len):\n                    parts.append(tok[i : i + max_len])\n    flush()\n    return parts\n"
    "path": "app/services/translate_service.py",
    "content": "from __future__ import annotations\n\nimport asyncio\nimport hashlib\nimport random\nimport time\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom urllib.parse import quote_plus\n\nimport aiohttp\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.db.models import TranslationCache, CardTranslation\n\n\n@dataclass(frozen=True)\nclass TranslateConfig:\n    enabled: bool\n    source_lang: str\n    target_lang: str\n    concurrency: int\n    min_delay_ms: int\n    max_retries: int\n    base_delay_ms: int\n    max_delay_ms: int\n\n\n# Module-level throttling across all imports in this process.\n_translate_gate = asyncio.Lock()\n_last_request_ts = 0.0\n\n\ndef _key(source_lang: str, target_lang: str, text: str) -> str:\n    norm = (text or \"\").strip()\n    raw = f\"{source_lang}|{target_lang}|{norm}\".encode(\"utf-8\")\n    return hashlib.sha256(raw).hexdigest()\n\n\nasync def _throttle(min_delay_ms: int) -> None:\n    global _last_request_ts\n    if min_delay_ms <= 0:\n        return\n    async with _translate_gate:\n        now = time.monotonic()\n        wait = (_last_request_ts + (min_delay_ms / 1000.0)) - now\n        if wait > 0:\n            await asyncio.sleep(wait)\n        _last_request_ts = time.monotonic()\n\n\ndef _parse_google_translate(payload) -> str:\n    # Expected shape: [[['translated','original',...], ...], ...]\n    try:\n        parts = payload[0]\n        if not isinstance(parts, list):\n            return \"\"\n        out = []\n        for seg in parts:\n            if isinstance(seg, list) and seg:\n                t = seg[0]\n                if isinstance(t, str):\n                    out.append(t)\n        return \"\".join(out).strip()\n    except Exception:\n        return \"\"\n\n\nasync def get_or_create_translation_cache(\n    db: AsyncSession,\n    *,\n    source_lang: str,\n    target_lang: str,\n    text: str,\n    cfg: TranslateConfig,\n    sem: asyncio.Semaphore,\n) -> Optional[str]:\n    \"\"\"Returns cache_key for translation_cache row, or None if translation disabled/failed.\"\"\"\n    if not cfg.enabled:\n        return None\n\n    src = (text or \"\").strip()\n    if not src:\n        return None\n\n    cache_key = _key(source_lang, target_lang, src)\n\n    # 1) cache hit\n    res = await db.execute(select(TranslationCache).where(TranslationCache.key == cache_key))\n    existing = res.scalar_one_or_none()\n    if existing:\n        return existing.key\n\n    # 2) cache miss -> call translate\n    translated = await translate_via_google(\n        source_lang=source_lang,\n        target_lang=target_lang,\n        text=src,\n        cfg=cfg,\n        sem=sem,\n    )\n    if not translated:\n        return None\n\n    db.add(\n        TranslationCache(\n            key=cache_key,\n            source_lang=source_lang,\n            target_lang=target_lang,\n            source_text=src,\n            translated_text=translated,\n        )\n    )\n    # Flush so the row is visible to subsequent selects within the same transaction.\n    await db.flush()\n    return cache_key\n\n\nasync def translate_via_google(\n    *,\n    source_lang: str,\n    target_lang: str,\n    text: str,\n    cfg: TranslateConfig,\n    sem: asyncio.Semaphore,\n) -> Optional[str]:\n    \"\"\"Unofficial endpoint. Retries on 429/5xx with exponential backoff.\"\"\"\n    # NOTE: This is an unofficial Google endpoint. For production, prefer an official provider.\n    encoded_text = quote_plus(text)\n    url = (\n        \"https://translate.googleapis.com/translate_a/single\"\n        f\"?client=gtx&sl={source_lang}&tl={target_lang}&dt=t&q={encoded_text}\"\n    )\n\n    timeout = aiohttp.ClientTimeout(total=25)\n\n    attempt = 0\n    while True:\n        attempt += 1\n        try:\n            async with sem:\n                await _throttle(cfg.min_delay_ms)\n                async with aiohttp.ClientSession(timeout=timeout) as session:\n                    async with session.get(url) as resp:\n                        status = resp.status\n                        if status == 200:\n                            payload = await resp.json(content_type=None)\n                            out = _parse_google_translate(payload)\n                            if out:\n                                return out\n                            # empty/unknown payload: treat as retryable for a few attempts\n                        elif status in (429, 500, 502, 503, 504):\n                            # retryable\n                            pass\n                        else:\n                            # non-retryable\n                            return None\n        except (aiohttp.ClientError, asyncio.TimeoutError):\n            pass\n        except Exception:\n            # Unknown failure: do not loop forever.\n            return None\n\n        if attempt >= max(1, cfg.max_retries):\n            return None\n\n        # exponential backoff + jitter\n        delay = cfg.base_delay_ms * (2 ** (attempt - 1))\n        delay = min(delay, cfg.max_delay_ms)\n        jitter = random.uniform(0.0, 0.25) * delay\n        await asyncio.sleep((delay + jitter) / 1000.0)\n\n\nasync def link_card_translation(db: AsyncSession, *, card_id: str, cache_key: str) -> None:\n    \"\"\"Creates card_translations row (card_id -> translation_cache.key).\"\"\"\n    if not cache_key:\n        return\n    db.add(CardTranslation(card_id=card_id, cache_key=cache_key))\n    await db.flush()\n"
    "path": "app/utils/diff_highlight.py",
    "content": "from __future__ import annotations\n\nimport html\nimport re\nfrom difflib import SequenceMatcher\nfrom typing import List, Tuple\n\n_WORD_RE = re.compile(r\"[A-Za-z0-9]+(?:'[A-Za-z0-9]+)?\")\n\ndef _tokens(text: str) -> List[str]:\n    if not text:\n        return []\n    return _WORD_RE.findall(text)\n\ndef highlight_diff(correct: str, user: str) -> tuple[str, str]:\n    \"\"\"Return (correct_html, user_html) with minimal markup.\n    - In Correct: underline (<u>) words the user missed or got wrong.\n    - In You: bold (<b>) extra/wrong words.\n    \"\"\"\n    c = _tokens(correct)\n    u = _tokens(user)\n\n    c_low = [t.lower() for t in c]\n    u_low = [t.lower() for t in u]\n\n    sm = SequenceMatcher(a=c_low, b=u_low)\n    c_out: list[str] = []\n    u_out: list[str] = []\n\n    def esc(t: str) -> str:\n        return html.escape(t, quote=False)\n\n    for tag, i1, i2, j1, j2 in sm.get_opcodes():\n        if tag == \"equal\":\n            for t in c[i1:i2]:\n                c_out.append(esc(t))\n            for t in u[j1:j2]:\n                u_out.append(esc(t))\n        elif tag == \"delete\":\n            # present in correct, missing in user\n            for t in c[i1:i2]:\n                c_out.append(f\"<u>{esc(t)}</u>\")\n        elif tag == \"insert\":\n            # extra in user\n            for t in u[j1:j2]:\n                u_out.append(f\"<b>{esc(t)}</b>\")\n        elif tag == \"replace\":\n            for t in c[i1:i2]:\n                c_out.append(f\"<u>{esc(t)}</u>\")\n            for t in u[j1:j2]:\n                u_out.append(f\"<b>{esc(t)}</b>\")\n\n    return (\" \".join(c_out).strip(), \" \".join(u_out).strip())\n"
    "path": "app/utils/html_strip.py",
    "content": "from __future__ import annotations\nimport re\nimport html\n\n_TAG_RE = re.compile(r\"<[^>]+>\")\n_BR_RE = re.compile(r\"(?i)<br\\s*/?>\")\n\ndef strip_html(s: str) -> str:\n    if not s:\n        return \"\"\n    s = html.unescape(s)\n    s = _BR_RE.sub(\"\\n\", s)\n    s = _TAG_RE.sub(\"\", s)\n    s = s.replace(\"\\xa0\", \" \")\n    s = re.sub(r\"[\\t\\r]+\", \" \", s)\n    s = re.sub(r\"\\n+\", \"\\n\", s)\n    return s.strip()\n"
    "path": "app/utils/locks.py",
    "content": "from __future__ import annotations\n\nimport asyncio\nfrom collections import defaultdict\nfrom typing import Hashable\n\nclass LockRegistry:\n    def __init__(self) -> None:\n        self._locks: dict[Hashable, asyncio.Lock] = defaultdict(asyncio.Lock)\n\n    def lock(self, key: Hashable) -> asyncio.Lock:\n        return self._locks[key]\n"
    "path": "app/utils/similarity.py",
    "content": "from __future__ import annotations\n\nfrom rapidfuzz import fuzz\n\ndef similarity_score(a: str, b: str) -> int:\n    # 0..100\n    return int(round(fuzz.ratio(a, b)))\n"
    "path": "app/utils/text_norm.py",
    "content": "from __future__ import annotations\nimport re\n\n_PUNCT_RE = re.compile(r\"[\\.,!?;:\\\"\u201c\u201d\\(\\)\\[\\]\\{\\}\u2014\\-\u2026]\")\n_APOS_RE = re.compile(r\"[\u2019`\u00b4]\")\n\ndef normalize_answer(text: str) -> str:\n    if text is None:\n        return \"\"\n    t = text.strip().lower()\n    t = _APOS_RE.sub(\"'\", t)\n    t = _PUNCT_RE.sub(\" \", t)\n    # Remove any remaining stray punctuation-like chars\n    t = re.sub(r\"[^a-z0-9\\s']\", \" \", t)\n    t = re.sub(r\"\\s+\", \" \", t).strip()\n    return t\n"
    "path": "app/utils/timez.py",
    "content": "from __future__ import annotations\n\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n\ndef now_tz(tz_name: str) -> datetime:\n    return datetime.now(tz=ZoneInfo(tz_name))\n\ndef today_date(tz_name: str):\n    return now_tz(tz_name).date()\n"
  },
  {
    "path": "requirements.txt",
    "content": "aiogram>=3.6.0,<4.0.0\nSQLAlchemy>=2.0.0,<3.0.0\naiosqlite>=0.20.0\nasyncpg>=0.29.0\npython-dotenv>=1.0.0\nrapidfuzz>=3.9.0\nfastapi>=0.110.0,<1.0.0\nuvicorn[standard]>=0.27.0,<1.0.0\npython-multipart>=0.0.9,<1.0.0\naiohttp>=3.9.0,<4.0.0\npytest>=8.2.0\npytest-asyncio>=0.23.0\n"
  },
  {
    "path": "systemd/anki_listen_bot.service",
    "content": "[Unit]\nDescription=anki_listen_bot\nAfter=network.target\n\n[Service]\nType=simple\nWorkingDirectory=/opt/anki_listen_bot\nEnvironmentFile=/opt/anki_listen_bot/.env\nExecStart=/opt/anki_listen_bot/.venv/bin/python -m app.main\nRestart=always\nRestartSec=2\n\n[Install]\nWantedBy=multi-user.target\n"
  },
  {
    "path": "tests/conftest.py",
    "content": "import os\nimport sys\n\nROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\nif ROOT not in sys.path:\n    sys.path.insert(0, ROOT)\n\nimport pytest_asyncio\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\n\nfrom app.db.models import Base\n\n\n@pytest_asyncio.fixture()\nasync def sessionmaker():\n    engine = create_async_engine(\"sqlite+aiosqlite:///:memory:\", future=True)\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    maker = async_sessionmaker(bind=engine, expire_on_commit=False)\n    try:\n        yield maker\n    finally:\n        await engine.dispose()\n"
  },
  {
    "path": "tests/test_admin_students.py",
    "content": "from datetime import date, datetime, timedelta\n\nimport pytest\nfrom sqlalchemy import select\n\nfrom app.db.models import Deck, Card, User, Review, Enrollment, StudySession, Flag\nfrom app.db.repo import (\n    unenroll_student_wipe_progress,\n    unenroll_all_students_wipe_progress,\n    compute_overall_progress,\n)\nfrom app.services.student_progress import get_daily_progress_history, get_today_progress\n\n\n@pytest.mark.asyncio\nasync def test_unenroll_student_wipe_progress(sessionmaker):\n    async with sessionmaker() as session:\n        deck = Deck(admin_tg_id=1, title=\"Deck\", token=\"t1\", new_per_day=10)\n        other_deck = Deck(admin_tg_id=1, title=\"Deck2\", token=\"t2\", new_per_day=10)\n        user = User(tg_id=100)\n        other_user = User(tg_id=200)\n        session.add_all([deck, other_deck, user, other_user])\n        await session.commit()\n        await session.refresh(deck)\n        await session.refresh(other_deck)\n        await session.refresh(user)\n        await session.refresh(other_user)\n\n        card = Card(deck_id=deck.id, note_guid=\"n1\", answer_text=\"a1\", alt_answers=[], media_kind=\"audio\", tg_file_id=\"f1\", media_sha256=\"s1\")\n        other_card = Card(deck_id=other_deck.id, note_guid=\"n2\", answer_text=\"a2\", alt_answers=[], media_kind=\"audio\", tg_file_id=\"f2\", media_sha256=\"s2\")\n        session.add_all([card, other_card])\n        await session.commit()\n        await session.refresh(card)\n        await session.refresh(other_card)\n\n        session.add_all([\n            Enrollment(user_id=user.id, deck_id=deck.id),\n            Enrollment(user_id=user.id, deck_id=other_deck.id),\n            Enrollment(user_id=other_user.id, deck_id=deck.id),\n            Review(user_id=user.id, card_id=card.id, state=\"learning\"),\n            Review(user_id=user.id, card_id=other_card.id, state=\"learning\"),\n            Review(user_id=other_user.id, card_id=card.id, state=\"review\"),\n            StudySession(user_id=user.id, deck_id=deck.id, study_date=date.today(), queue=[\"c1\"], pos=1),\n            StudySession(user_id=user.id, deck_id=other_deck.id, study_date=date.today(), queue=[\"c2\"], pos=1),\n            Flag(user_id=user.id, card_id=card.id),\n            Flag(user_id=other_user.id, card_id=card.id),\n        ])\n        await session.commit()\n\n        await unenroll_student_wipe_progress(session, user.id, deck.id)\n\n        enr_rows = await session.execute(select(Enrollment).where(Enrollment.user_id == user.id, Enrollment.deck_id == deck.id))\n        assert enr_rows.first() is None\n        # Other enrollments intact\n        other_enr = await session.execute(select(Enrollment).where(Enrollment.user_id == user.id, Enrollment.deck_id == other_deck.id))\n        assert other_enr.first() is not None\n        other_user_enr = await session.execute(select(Enrollment).where(Enrollment.user_id == other_user.id, Enrollment.deck_id == deck.id))\n        assert other_user_enr.first() is not None\n\n        rev_rows = await session.execute(select(Review).where(Review.user_id == user.id, Review.card_id == card.id))\n        assert rev_rows.first() is None\n        other_review = await session.execute(select(Review).where(Review.user_id == user.id, Review.card_id == other_card.id))\n        assert other_review.first() is not None\n        other_user_review = await session.execute(select(Review).where(Review.user_id == other_user.id, Review.card_id == card.id))\n        assert other_user_review.first() is not None\n\n        ss_rows = await session.execute(select(StudySession).where(StudySession.user_id == user.id, StudySession.deck_id == deck.id))\n        assert ss_rows.first() is None\n        other_ss = await session.execute(select(StudySession).where(StudySession.user_id == user.id, StudySession.deck_id == other_deck.id))\n        assert other_ss.first() is not None\n\n        flag_rows = await session.execute(select(Flag).where(Flag.user_id == user.id, Flag.card_id == card.id))\n        assert flag_rows.first() is None\n        other_flag = await session.execute(select(Flag).where(Flag.user_id == other_user.id, Flag.card_id == card.id))\n        assert other_flag.first() is not None\n\n\n@pytest.mark.asyncio\nasync def test_unenroll_all_students_wipe_progress(sessionmaker):\n    async with sessionmaker() as session:\n        deck = Deck(admin_tg_id=1, title=\"Deck\", token=\"t1\", new_per_day=10)\n        other_deck = Deck(admin_tg_id=1, title=\"Deck2\", token=\"t2\", new_per_day=10)\n        user = User(tg_id=100)\n        other_user = User(tg_id=200)\n        session.add_all([deck, other_deck, user, other_user])\n        await session.commit()\n        await session.refresh(deck)\n        await session.refresh(other_deck)\n        await session.refresh(user)\n        await session.refresh(other_user)\n\n        card = Card(deck_id=deck.id, note_guid=\"n1\", answer_text=\"a1\", alt_answers=[], media_kind=\"audio\", tg_file_id=\"f1\", media_sha256=\"s1\")\n        other_card = Card(deck_id=other_deck.id, note_guid=\"n2\", answer_text=\"a2\", alt_answers=[], media_kind=\"audio\", tg_file_id=\"f2\", media_sha256=\"s2\")\n        session.add_all([card, other_card])\n        await session.commit()\n        await session.refresh(card)\n        await session.refresh(other_card)\n\n        session.add_all([\n            Enrollment(user_id=user.id, deck_id=deck.id),\n            Enrollment(user_id=other_user.id, deck_id=deck.id),\n            Enrollment(user_id=user.id, deck_id=other_deck.id),\n            Review(user_id=user.id, card_id=card.id, state=\"learning\"),\n            Review(user_id=other_user.id, card_id=card.id, state=\"learning\"),\n            Review(user_id=user.id, card_id=other_card.id, state=\"learning\"),\n            StudySession(user_id=user.id, deck_id=deck.id, study_date=date.today(), queue=[\"c1\"], pos=1),\n            Flag(user_id=user.id, card_id=card.id),\n            Flag(user_id=other_user.id, card_id=card.id),\n        ])\n        await session.commit()\n\n        await unenroll_all_students_wipe_progress(session, deck.id)\n\n        assert (await session.execute(select(Enrollment).where(Enrollment.deck_id == deck.id))).first() is None\n        assert (await session.execute(select(Review).where(Review.card_id == card.id))).first() is None\n        assert (await session.execute(select(StudySession).where(StudySession.deck_id == deck.id))).first() is None\n        assert (await session.execute(select(Flag).where(Flag.card_id == card.id))).first() is None\n        # Other deck untouched\n        assert (await session.execute(select(Enrollment).where(Enrollment.deck_id == other_deck.id))).first() is not None\n        assert (await session.execute(select(Review).where(Review.card_id == other_card.id))).first() is not None\n\n\n@pytest.mark.asyncio\nasync def test_progress_history_and_overall(sessionmaker):\n    async with sessionmaker() as session:\n        deck = Deck(admin_tg_id=1, title=\"Deck\", token=\"t1\", new_per_day=10)\n        user = User(tg_id=100)\n        session.add_all([deck, user])\n        await session.commit()\n        await session.refresh(deck)\n        await session.refresh(user)\n\n        card = Card(deck_id=deck.id, note_guid=\"n1\", answer_text=\"a1\", alt_answers=[], media_kind=\"audio\", tg_file_id=\"f1\", media_sha256=\"s1\")\n        session.add(card)\n        await session.commit()\n        await session.refresh(card)\n\n        base_date = date(2024, 1, 10)\n        sessions = [\n            StudySession(user_id=user.id, deck_id=deck.id, study_date=base_date, queue=[\"c1\", \"c2\", \"c3\"], pos=2),\n            StudySession(user_id=user.id, deck_id=deck.id, study_date=base_date + timedelta(days=1), queue=[\"c4\"], pos=1),\n            StudySession(user_id=user.id, deck_id=deck.id, study_date=base_date + timedelta(days=3), queue=[\"c5\", \"c6\"], pos=0),\n        ]\n        session.add_all(sessions)\n        session.add(Review(user_id=user.id, card_id=card.id, state=\"review\", due_at=datetime.utcnow() - timedelta(days=1)))\n        await session.commit()\n\n        today_progress = await get_today_progress(session, user.id, deck.id, base_date + timedelta(days=3))\n        assert today_progress == (0, 2)\n\n        history = await get_daily_progress_history(session, user.id, deck.id, base_date + timedelta(days=3), days=7)\n        assert len(history) == 7\n        history_map = {d: (done, total) for d, done, total in history}\n        assert history_map[base_date] == (2, 3)\n        assert history_map[base_date + timedelta(days=1)] == (1, 1)\n        assert history_map[base_date + timedelta(days=2)] == (0, 0)\n\n        overall = await compute_overall_progress(session, user.id, deck.id, now=datetime.utcnow())\n        assert overall[\"total_cards\"] == 1\n        assert overall[\"started\"] == 1\n        assert overall[\"states\"].get(\"review\") == 1\n        assert overall[\"due\"] == 1\n"
  },
  {
    "path": "tests/test_study_flow.py",
    "content": "from datetime import datetime, timedelta, date\nimport os\nimport sys\n\nROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\nif ROOT not in sys.path:\n    sys.path.insert(0, ROOT)\n\nimport pytest\nfrom app.db.models import Deck, Card, User, Review\nfrom app.services.study_engine import ensure_current_card, record_answered_card\nfrom app.services.scheduler import _run_due_learning_push_once\nfrom app.db.repo import create_today_session, get_today_session, update_session_progress\n\n\nasync def _seed_basic(session):\n    deck = Deck(admin_tg_id=1, title=\"Deck\", token=\"tok\", new_per_day=10)\n    user = User(tg_id=100)\n    session.add_all([deck, user])\n    await session.commit()\n    await session.refresh(deck)\n    await session.refresh(user)\n    return deck, user\n\n\ndef _make_card(deck_id: str, note_guid: str, suffix: str) -> Card:\n    return Card(\n        deck_id=deck_id,\n        note_guid=note_guid,\n        answer_text=f\"ans-{suffix}\",\n        alt_answers=[],\n        media_kind=\"audio\",\n        tg_file_id=f\"file-{suffix}\",\n        media_sha256=f\"sha-{suffix}\",\n    )\n\n\n@pytest.mark.asyncio\nasync def test_learning_card_prioritized_over_main_queue(sessionmaker):\n    async with sessionmaker() as session:\n        deck, user = await _seed_basic(session)\n        main_card = _make_card(deck.id, \"n1\", \"main\")\n        learn_card = _make_card(deck.id, \"n2\", \"learn\")\n        session.add_all([main_card, learn_card])\n        await session.commit()\n        await session.refresh(main_card)\n        await session.refresh(learn_card)\n\n        session.add(\n            Review(\n                user_id=user.id,\n                card_id=learn_card.id,\n                state=\"learning\",\n                due_at=datetime.utcnow() - timedelta(minutes=1),\n            )\n        )\n        await session.commit()\n\n        study_date = date.today()\n        cid = await ensure_current_card(session, user.id, deck.id, study_date, datetime.utcnow())\n        assert cid == learn_card.id\n\n\n@pytest.mark.asyncio\nasync def test_record_answered_card_updates_pos_only_for_main_queue(sessionmaker):\n    async with sessionmaker() as session:\n        deck, user = await _seed_basic(session)\n        main_card = _make_card(deck.id, \"n1\", \"main\")\n        learn_card = _make_card(deck.id, \"n2\", \"learn\")\n        session.add_all([main_card, learn_card])\n        await session.commit()\n        await session.refresh(main_card)\n        await session.refresh(learn_card)\n\n        study_date = date.today()\n        sess = await create_today_session(session, user.id, deck.id, study_date, [main_card.id])\n\n        # main queue card increments pos\n        await record_answered_card(session, sess, main_card.id)\n        updated = await get_today_session(session, user.id, deck.id, study_date)\n        assert updated.pos == 1\n\n        # learning repeat does not increment\n        await update_session_progress(session, sess.id, 0, None)\n        session.add(\n            Review(\n                user_id=user.id,\n                card_id=learn_card.id,\n                state=\"learning\",\n                due_at=datetime.utcnow() - timedelta(minutes=1),\n            )\n        )\n        await session.commit()\n        await record_answered_card(session, sess, learn_card.id)\n        sess_after = await get_today_session(session, user.id, deck.id, study_date)\n        assert sess_after.pos == 0\n\n\n@pytest.mark.asyncio\nasync def test_scheduler_skips_when_current_card_active(sessionmaker):\n    calls = []\n\n    async with sessionmaker() as session:\n        deck, user = await _seed_basic(session)\n        learn_card = _make_card(deck.id, \"n1\", \"learn\")\n        session.add(learn_card)\n        await session.commit()\n        await session.refresh(learn_card)\n\n        session.add(\n            Review(\n                user_id=user.id,\n                card_id=learn_card.id,\n                state=\"learning\",\n                due_at=datetime.utcnow() - timedelta(minutes=1),\n            )\n        )\n        await session.commit()\n\n        study_date = date.today()\n        sess = await create_today_session(session, user.id, deck.id, study_date, [])\n        sess.current_card_id = learn_card.id\n        await session.commit()\n\n    async def _send(bot, chat_id, card, deck_id):\n        calls.append(card.id)\n\n    await _run_due_learning_push_once(bot=None, settings=type(\"S\", (), {\"tz\": \"UTC\"}), sessionmaker=sessionmaker, send_card_fn=_send)\n    assert calls == []\n\n\n@pytest.mark.asyncio\nasync def test_scheduler_sends_learning_after_main_queue(sessionmaker):\n    calls = []\n\n    async with sessionmaker() as session:\n        deck, user = await _seed_basic(session)\n        learn_card = _make_card(deck.id, \"n1\", \"learn\")\n        session.add(learn_card)\n        await session.commit()\n        await session.refresh(learn_card)\n\n        session.add(\n            Review(\n                user_id=user.id,\n                card_id=learn_card.id,\n                state=\"learning\",\n                due_at=datetime.utcnow() - timedelta(minutes=1),\n            )\n        )\n        await session.commit()\n\n        study_date = date.today()\n        sess = await create_today_session(session, user.id, deck.id, study_date, [])\n        sess.pos = 0\n        await session.commit()\n\n    async def _send(bot, chat_id, card, deck_id):\n        calls.append(card.id)\n\n    await _run_due_learning_push_once(bot=None, settings=type(\"S\", (), {\"tz\": \"UTC\"}), sessionmaker=sessionmaker, send_card_fn=_send)\n    assert calls == [learn_card.id]\n"